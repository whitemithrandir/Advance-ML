## Making recommendations
Makine öğrenimi uzmanlığının bu ikinci ila son haftasına hoş geldiniz. Neredeyse bitiş çizgisine kadar birlikte olduğum için çok mutluyum. Bu hafta yapacağımız şey önerilen sistemleri tartışmak. Bu, akademide oldukça dikkat çeken konulardan biri. Ancak önerilen sistemlerin ticari etkisi ve gerçek pratik kullanım durumlarının sayısı bana akademide aldığı ilgiden çok daha büyük görünüyor. Amazon gibi bir çevrimiçi alışveriş sitesine veya Netflix gibi bir film akışı sitesine her gittiğinizde veya yemek dağıtımı yapan uygulamalardan veya sitelerden birine gittiğinizde. Bu sitelerin çoğu, satın almak isteyebileceğinizi düşündükleri şeyleri veya izlemek isteyebileceğinizi düşündükleri filmleri veya denemek isteyebileceğinizi düşündükleri restoranları size önerecektir. Ve birçok şirket için satışların büyük bir kısmı önerilen sistemlerinden kaynaklanmaktadır. Bugün birçok şirket için ekonomi ya da önerilen sistemlerin yönlendirdiği değer çok büyük ve bu hafta yaptığımız şey nasıl çalıştıklarına bir göz atmak. Öyleyse bununla dalalım ve önerilen bir sistemin ne olduğuna bir göz atalım. Çalışan bir örnek olarak, film derecelendirmelerini tahmin etme uygulamasını kullanacağım. Diyelim ki büyük bir film akışı web sitesi işletiyorsunuz ve kullanıcılarınız filmleri bir ila beş yıldız kullanarak derecelendirdi. Ve böylece tipik bir önerilen sistemde bir dizi kullanıcınız var, burada dört kullanıcımız var Alice, Bob Carol ve Dave. Kullanıcıları 1,2,3,4 olarak numaralandırmıştır. Bir dizi filmin yanı sıra Sonunda aşk, Sonsuza dek romantizm, Sevimli aşk yavruları ve ardından Kesintisiz araba kovalamacaları ve karate'ye karşı Kılıç. Ve kullanıcıların yaptığı şey bu filmleri bir ila beş yıldız arasında derecelendirmek. Ya da aslında bu örneklerden bazılarını biraz daha kolaylaştırmak için. Filmleri sıfırdan beş yıldıza derecelendirmelerine izin vermeyeceğim. Öyleyse Alice'in Aşkı ve son beş yıldızı, Romantizmi sonsuza dek beş yıldız olarak derecelendirdiğini söyleyin. Belki de henüz sevimli aşk yavrularını izlememiştir, bu yüzden bunun için bir puanınız yoktur. Ve bunu bir soru işareti ile belirteceğim ve kesintisiz araba kovalamacalarının ve karate'ye karşı kılıcın sıfır yıldız bob'u hak ettiğini düşünüyor. Beş yıldızda yarış bunu izlemedi, bu yüzden dört yıldızda derecelendirme yarışınız yok, 0,0. Öte yandan Carol, sıfır yıldızı hak eden şeyler o sıfır yıldızı izlemedi ve durmadan araba kovalamayı ve karate'ye karşı kılıçları seviyor ve Dave filmleri şu şekilde yükseltiyor. Tipik önerilen sistemde, bazı kullanıcıların yanı sıra bazı öğelerin sayısı da vardır. Bu durumda öğeler, kullanıcılara önermek istediğiniz filmlerdir. Ve bu örnekte filmleri kullanmama rağmen, aynı mantık veya aynı şey. Ürünlerden veya web sitesinden restoranlara, hatta hangi medya makalelerine, sosyal medya makalelerinin gösterileceğine, kullanıcıya kendileri için daha ilginç olabilecek her şeyi tavsiye etmeye çalışın. Kullanacağım gösterim, kullanıcı sayısını belirtmek için nu'yu kullanacağım. Yani bu örnekte nu dörde eşittir çünkü film sayısını veya gerçekten öğe sayısını belirtmek için dört kullanıcınız ve nm'niz vardır. Yani bu örnekte nm beşe eşittir çünkü beş filmimiz var. Kullanıcı j filmi i olarak derecelendirmişse, r (i, j) = 1 değerini ayarlayacağım. Örneğin, bir tane kullanın Dallas Alice birinci filmi derecelendirdi ancak üçüncü filmi derecelendirmedi ve bu nedenle r (1,1) = 1, çünkü birinci filmi derecelendirdi, ancak r(3,1) = 0 çünkü üçüncü filmi derecelendirmedi. Sonunda y (ı, j) kullanacağım. Örneğin, buradaki bu derecelendirme, üçüncü filmin kullanıcı 2 tarafından dörde eşit olarak derecelendirilmesi olacaktır. Her kullanıcının her filmi derecelendirmediğine ve sistemin hangi kullanıcıların hangi filmleri derecelendirdiğini bilmesinin önemli olduğuna dikkat edin. Bu yüzden tanımlayacağız r (i, j) = 1 eğer kullanıcı j film i'yi derecelendirmişse ve kullanıcı j film i'yi derecelendirmemişse sıfıra eşit olacaktır. Bu nedenle, önerilen sistemler için bu çerçeveyle soruna yaklaşmanın olası bir yolu, kullanıcıların izlediği filmlere bakmaktır. puan vermedim. Ve kullanıcıların bu filmleri nasıl derecelendireceğini tahmin etmeye çalışmak çünkü o zaman kullanıcılara beş yıldız olarak derecelendirmeleri daha muhtemel olan şeyleri önermeye çalışabiliriz. Ve bir sonraki videoda tam olarak bunu yapmak için bir algoritma geliştirmeye başlayacağız. Ama çok özel bir varsayımda bulunmak. Geçici olarak, hangi filmlerin romantik filmler, hangi filmlerin aksiyon filmleri olduğu gibi filmlerle ilgili özelliklere veya ek bilgilere erişebileceğimizi varsayacağız. Ve bunu kullanmak bir algoritma geliştirmeye başlayacaktır. Ama bu hafta sonra gerçekten geri dönecek ve soracak ya bu özelliklere sahip değilsek, algoritmayı o zaman nasıl çalıştırabilirsin? Ama bu algoritmayı oluşturmaya başlamak için bir sonraki videoya geçelim.

## Using per-item features
Öyleyse, her bir öğenin özelliklerine veya her filmin özelliklerine sahip olsaydık önerilen bir sistemi nasıl geliştirebileceğimize bir göz atalım. İşte daha önce dört kullanıcının beş filmin tümünü değil, bazılarını derecelendirdiği aynı veri seti. Ya ek olarak filmlerin özelliklerine sahipsek? Bu yüzden burada, her birinin ne kadar romantik bir film olduğunu ve bunların her birinin ne kadar aksiyon filmi olduğunu söyleyen iki özellik X1 ve X2 ekledim. Örneğin Sonunda Aşk çok romantik bir film, bu yüzden bu özellik 0,9 alıyor ama hiç de aksiyon filmi değil. Yani bu özellik 0 alır. Ama Kesintisiz Araba kovalamacalarının içinde biraz romantizm olduğu ortaya çıktı. Yani 0.1, ama bir ton aksiyonu var. Böylece bu özellik 1.0 değerini alır. Hatırlıyorsunuz ki, kullanıcı sayısını belirtmek için nu gösterimini kullanmıştım, bu 4 ve m, 5 olan film sayısını belirtmek için. Burada sahip olduğumuz özelliklerin sayısını belirtmek için n'yi de tanıtacağım. Ve böylece n = 2, çünkü her film için iki X1 ve X2 özelliğimiz var. Bu özelliklerle, örneğin birinci filmin, yani Sonunda Aşk filminin özelliklerinin 0,90 olacağına sahibiz. Ve üçüncü filmin özellikleri Sevimli Aşk Yavruları 0,99 ve 0 olurdu. Ve Alice'in film reytingleri için nasıl tahminlerde bulunabileceğimize bir göz atarak başlayalım. Yani birinci kullanıcı için, yani Alice, diyelim ki film i için derecelendirmeyi w.X (i) + b olarak tahmin ediyoruz. Yani bu sadece doğrusal regresyona çok benziyor. Örneğin, w(1) = [5,0] parametresini seçip b (1) = 0 dersek, özelliklerin 0,99 ve 0 olduğu üçüncü film için tahmin, buradan yeni kopyalanan, ilk özellik 0,99, ikinci özellik 0. Tahminimiz w.X (3) + b = 0,99 çarpı 5 artı 0 çarpı sıfır olacaktır, bu da 4,95'e eşittir. Ve bu derecelendirme oldukça makul görünüyor. Görünüşe göre Alice, son derece romantik iki filme Sonunda Aşka ve Sonsuza kadar Romantizme yüksek puanlar vermiş, ancak aksiyon filmlerine, Kesintisiz Araba Kovalamalarına ve Kılıçlara karşı Karate'ye düşük puanlar vermiş. Yani Sevimli Aşk Yavrularına bakarsak, bunu 4,95 olarak değerlendirebileceğini tahmin etmek oldukça makul görünüyor. Ve böylece Alice için bu parametreler w ve b, film derecelendirmelerini tahmin etmek için makul bir model gibi görünüyor. Notasyonu biraz ekleyin çünkü sadece bir kullanıcımız değil, birden fazla kullanıcımız var veya gerçekten nu 4 kullanıcıya eşittir. Bunun, kullanıcı 1 için w (1) parametresi olduğunu belirtmek için buraya bir üst simge 1 ekleyeceğim ve oraya da bir süper şerit 1 ekleyeceğim. Ve benzer şekilde burada ve burada da, böylece veri kümesindeki 4 kullanıcının her biri için aslında farklı parametrelere sahip olacağız. Ve daha genel olarak bu modelde, sadece kullanıcı 1 için değil, kullanıcı j'nin film ı için derecelendirmesini w (j) olarak tahmin edebiliriz.X(ı)+b(j). Yani burada w (j) ve b (j) parametreleri, film i'nin özellikleri olan X (i) 'nin bir fonksiyonu olan film i için kullanıcı j'nin derecelendirmesini tahmin etmek için kullanılan parametrelerdir. Ve bu, doğrusal regresyona çok benziyor, ancak farklı bir veri kümesindeki 4 kullanıcının her biri için doğrusal regresyon modeli. Şimdi bu algoritma için maliyet fonksiyonunu nasıl formüle edebileceğimize bir göz atalım. Gösterimde bir hatırlatma olarak, kullanıcı j filmi i veya 0 olarak derecelendirmişse r (i., j) = 1'dir. Ve y(i, j) = kullanıcı tarafından verilen derecelendirme j filmde i. Ve önceki tarafta tanımladık w (j), b (j) kullanıcı parametreleri olarak j. Ve film i için özellik vektörü olarak X (i). Yani sahip olduğumuz model j kullanıcısı içindir ve derecelendirmenin w (j) olduğunu tahmin ettiğim film içindir.X(ı)+b(j). Sadece yeni bir gösterim parçası sunacağım, yani kullanıcı j tarafından derecelendirilen film sayısını belirtmek için m (j) kullanacağım. Yani kullanıcı 4 film derecelendirmişse, m (j) 4'e eşit olacaktır. Ve eğer kullanıcı 3 filmi derecelendirmişse, m (j) 3'e eşit olacaktır. Yani yapmak istediğimiz şey, sahip olduğumuz veriler göz önüne alındığında, w (j) ve b (j) parametrelerini öğrenmektir. Bu, bir kullanıcının bir dizi film için verdiği derecelendirmelere verilir. Yani kullanacağımız ortalama, doğrusal regresyona çok benzer. Bu yüzden, belirli bir j kullanıcısı için w (j) ve b (j) parametrelerini öğrenmek için maliyet fonksiyonunu yazalım. Ve şimdilik sadece bir kullanıcıya j kullanıcısına odaklanalım. Ortalama kare hata ölçütünü kullanacağım. Yani maliyet, w (j) olan tahmin olacaktır.X (i) + b (j) eksi kullanıcının verdiği gerçek derecelendirme. Yani eksi y (i, j) karesi. Ve tahmin edilen derecelendirme ile gözlemlenen gerçek derecelendirme arasındaki kare hatasını en aza indirmek için w ve b parametrelerini seçmeye çalışıyoruz. Ancak kullanıcı tüm filmleri derecelendirmedi, bu yüzden bunu özetleyeceksek, yalnızca r (i, j) = 1 olan i değerlerinin üzerinden özetleyeceğiz. Bu yüzden sadece j kullanıcısının gerçekten derecelendirdiği filmleri özetleyeceğiz. Yani bu, r (i, j) = 1 olduğu i'nin tüm değerlerinin toplamı anlamına gelir. Bu, j kullanıcısının o filmi i olarak derecelendirdiği anlamına gelir. Ve son olarak, normal normalleştirme 1'i m (j) üzerinden alabiliriz. Ve bu, m veya gerçekten m (j) eğitim örnekleriyle doğrusal regresyon için sahip olduğumuz maliyet fonksiyonuna çok benziyor. Kare hatası alan bir derecelendirmeye sahip olduğunuz m (j) filmlerini özetlediğiniz ve bu 1'in 2m (j) üzerinden normalleştirdiğiniz yer. Ve bu bir maliyet fonksiyonu olacak J nın-nin w (j), b (j). Ve bunu w (j) ve b (j) 'nin bir fonksiyonu olarak en aza indirirsek, o zaman w (i) ve b (j) parametrelerinin oldukça iyi bir seçimini yapmalısınız. Kullanıcı j'nin derecelendirmeleri için tahminlerde bulunmak için. Bu maliyet fonksiyonuna sadece bir terim daha vereyim, bu da aşırı uyumu önlemek için düzenleme terimidir. Ve işte her zamanki düzenleme parametremiz, lambda bölü 2m (j) ve sonra w parametrelerinin kare değerlerinin toplamı olarak çarpı. Ve böylece n, X (i) 'deki bir sayı sayısıdır ve bu, w (j) 'deki bir sayı sayısıyla aynıdır. Bu maliyeti en aza indirecek olsaydınız işlev J w ve b'nin bir fonksiyonu olarak, kullanıcı j'nin diğer filmler için derecelendirmelerini tahmin etmek için oldukça iyi bir parametre seti almalısınız. Şimdi, devam etmeden önce, önerilen sistemler için bu bölünmeyi m (j) terimiyle fiilen ortadan kaldırmanın uygun olacağı ortaya çıktı, m (j) bu ifadede sadece bir sabit. Ve böylece, onu çıkarsanız bile, aynı w ve b değerine sahip olmalısınız. Şimdi bu maliyet fonksiyonunu en alta indireyim ve bir sonraki slayda kopyalayayım. Bu nedenle, j kullanıcısı için w (j), b (j) parametrelerini öğrenmeliyiz. Bu maliyet fonksiyonunu w (j) ve b (j) 'nin bir fonksiyonu olarak en aza indiririz. Ancak tek bir kullanıcıya odaklanmak yerine, tüm kullanıcılar için parametreleri nasıl öğrendiğimize bakalım. W(1), b(1), w(2), b(2) parametrelerini öğrenmek,..., w (nu), b (nu), bu maliyet işlevini en üste alır ve tüm nu kullanıcılarının üzerine toplardık. Dolayısıyla, yukarıda yazdığımız aynı maliyet fonksiyonunun j = 1'den nu'ya toplamını alırdık. Ve bu, tüm kullanıcılar için tüm parametreleri öğrenmenin maliyeti haline gelir. Ve bunu w (1), b (1) 'in w (nu), b (nu) boyunca bir fonksiyonu olarak en aza indirmek için degrade iniş veya başka bir optimizasyon algoritması kullanırsak, o zaman oldukça iyi bir dizi parametreniz olur. tüm kullanıcılar için film derecelendirmelerini tahmin etmek için. Ve bu algoritmanın doğrusal regresyona çok benzediğini fark edebilirsiniz, burada doğrusal regresyonun f (x) çıktısına benzer bir rol oynar. Ancak şimdi nu kullanıcılarının her biri için farklı bir doğrusal regresyon modeli eğitiyoruz. Bu özelliklere X1 ve X2 erişiminiz varsa, parametreleri bu şekilde öğrenebilir ve film derecelendirmelerini tahmin edebilirsiniz. Bu size filmlerin her birinin ne kadar olduğunu, bir aşk filmi olduğunu ve filmlerin her birinin bir aksiyon filmi ne kadar olduğunu söyler mi? Fakat bu özellikler nereden geliyor? Peki ya bu tahminleri yapmak isteyen filmler hakkında size yeterince ayrıntı veren özelliklere erişiminiz yoksa? Bir sonraki videoda, bu algoritmanın değiştirilmesine bakacağız. Önerilerde bulunduğunuza dair tahminlerde bulunmanıza izin verecekler. Az önce gördüğümüz algoritmayı çalıştırmak için filmlerin öğelerini yeterince ayrıntılı olarak tanımlayan gelişmiş özelliklere sahip olmasanız bile. Devam edelim ve bir sonraki videoda buna bir göz atalım

## Collaborative filtering algorithm
Son videoda, bunun ne kadar romantik bir film olduğunu ve bunun ne kadar aksiyon filmi olduğunu söyleyen x_1 ve x_2 özellikleri gibi her film için nasıl özelliklere sahip olduğunuzu gördünüz. Ardından, film derecelendirmelerini tahmin etmeyi öğrenmek için temel olarak doğrusal regresyonu kullanabilirsiniz. Peki ya bu özelliklere sahip değilseniz, x_1 ve x_2? Verilerden bu x_1 ve x_2 özelliklerini nasıl öğrenebileceğinize veya bulabileceğinize bir göz atalım. İşte daha önce sahip olduğumuz veriler. Peki ya x_1 ve x_2 için bu sayılara sahip olmak yerine, x_1 ve x_2 özelliklerinin değerlerinin ne olduğunu önceden bilmiyorsak? Onları burada soru işaretleriyle değiştireceğim. Şimdi, sadece illüstrasyon amacıyla, diyelim ki bir şekilde dört kullanıcı için parametreleri zaten öğrenmiştik. Birinci kullanıcı için w ^ 1 eşittir 5 ve 0 ve b ^ 1 eşittir 0 parametrelerini öğrendiğimizi varsayalım. W ^ 2 ayrıca 5, 0 b ^ 2, 0'dır. W ^ 3 0, 5 b ^ 3 0'dır ve kullanıcı için dört W ^ 4 de 0, 5 ve b ^ 4 0, 0'dır. Daha sonra bu parametreleri nasıl bulmuş olabileceğimiz konusunda endişeleneceğiz, w ve b. Ama diyelim ki onlara zaten sahibiz. Bir hatırlatma olarak, müzik j'nin film ı'deki derecelendirmesini tahmin etmek için, x_i artı b ^ j'nin özellikleri olan w ^ j nokta ürününü kullanacağız. Bu örneği basitleştirmek için, b'nin tüm değerleri aslında 0'a eşittir. Sadece biraz yazmayı azaltmak için, bu örneğin geri kalanında b'yi görmezden geleceğim. Birinci film için neyin makul özellikler olabileceğini tahmin etmeye nasıl çalışabileceğimize bir göz atalım. Bunlar soldaki parametrelerse, Alice'in filmi bir, 5 olarak derecelendirdiği göz önüne alındığında, o w ^ 1'e sahip olmalıyız.x ^ 1, yaklaşık 5 ve w ^ 2'ye eşit olmalıdır.x ^ 2 de yaklaşık 5'e eşit olmalıdır çünkü Bob bunu 5 olarak derecelendirdi. W ^ 3.x ^ 1, 0 ve w ^ 4'e yakın olmalıdır.x ^ 1 de 0'a yakın olmalıdır. Soru şu ki, burada sahip olduğumuz w için bu değerler göz önüne alındığında, x_1 için hangi seçim bu değerlerin doğru olmasına neden olacaktır? Olası bir seçenek, o ilk filmin özellikleri 1, 0 olsaydı, bu durumda w ^ 1 olurdu.x ^ 1, 5, w ^ 2'ye eşit olacaktır.x ^ 1, 5'e eşit olacak ve benzer şekilde, bu özellik vektörüne sahip w ^ 3 veya w ^ 4 nokta çarpımı x_1, 0'a eşit olacaktır. Sahip olduğumuz şey, burada dört kullanıcının tümü için parametreleriniz varsa ve bu örnekte eşleştirmeyi denemek istediğiniz dört derecelendirmeniz varsa, film için x_1 özellik vektörünü neyin listelediğine dair makul bir tahminde bulunabilirsiniz. Bu dört derecelendirme için iyi tahminler yapacak bir üst. Benzer şekilde, bu parametre vektörlerine sahipseniz, ikinci film için bir özellik vektörü x_2, üçüncü film için özellik vektörü x_3 vb. Algoritmanın bu ek filmlerle ilgili tahminlerini gerçekte ne olduğuna yakın hale getirmeye çalışabilirsiniz. kullanıcılar tarafından verilen derecelendirmeler. X_1 ve x_2 değerlerini gerçekten öğrenmek için bir maliyet işlevi bulalım. Bu arada, bunun yalnızca dört kullanıcı için parametrelerimiz olduğu için çalıştığına dikkat edin. Uygun özellikleri tahmin etmemize izin veren şey budur, x_1. Bu nedenle, tipik bir doğrusal regresyon uygulamasında, yalnızca tek bir kullanıcınız olsaydı, x_1 ve x_2 özelliklerinin ne olacağını anlamak için yeterli bilgiye sahip olmazsınız, bu nedenle doğrusal regresyon bağlamlarında 1. derste gördüğünüz x_1 özelliklerini bulamazsınız ve sıfırdan x_2. Ancak işbirliğine dayalı filtrelemede, aynı filmle aynı öğenin birden çok kullanıcısının derecelendirmelerine sahip olmanızdır. Bu özellikler için olası değerlerin neler olduğunu tahmin etmeyi mümkün kılan şey budur. Verilen w ^ 1, b ^ 1, w ^ 2, b ^ 2 ve benzeri aracılığıyla w ^ n_u ve b ^ n_u, n alt simgesi için u kullanıcılar. Belirli bir film için x ^ i özelliklerini öğrenmek istiyorsanız, kullanabileceğimiz bir maliyet işlevidir. Her zamanki gibi kare hatasını en aza indirmek isteyeceğim. Film ı'de j kullanıcısının tahmin ettiği derecelendirme bununla verilirse, gerçek film derecelendirmesi y, i, j'den kare farkı alalım. Daha önce olduğu gibi, tüm kullanıcıları özetleyelim j. Ancak bu, j'nin tüm değerlerinin toplamı olacaktır, burada r, i, j eşittir İ. Oraya her zamanki gibi 1,5 ekleyeceğim. Bunu x ^ i için bir maliyet işlevi olarak tanımladığım için. O zaman bunu x ^ i'nin bir işlevi olarak en aza indirirsek, film i için özellikleri seçiyor olursunuz. Bu nedenle, film i'yi derecelendiren tüm kullanıcılar J, seçtiğiniz özellikler arasındaki kare farkı en aza indirmeye çalışacağız x ^ i, tahmin edilen film derecelendirmesi eksi kullanıcının verdiği gerçek film derecelendirmesi açısından sonuçlanır. Son olarak, bir düzenleme terimi eklemek istiyorsak, olağan artı Lambda'yı 2'nin üzerine ekleriz, K eşittir 1 ile n, burada n her zamanki gibi x ^ i'nin kare özelliklerinin sayısıdır. Son olarak, x1 ile x ^ n_m arasındaki tüm özellikleri öğrenmek için n_m filmlerimiz olduğu için bu maliyet işlevini en üste alıp tüm filmlerin üzerine toplayabiliriz. Toplam ı, film sayısı ile 1'e eşittir ve ardından bu terimi yukarıdan alır ve bu, veri kümesindeki tüm filmlerin özelliklerini öğrenmek için bir maliyet işlevi haline gelir. Dolayısıyla, w ve b parametreleriniz varsa, tüm kullanıcılar, daha sonra bu maliyet işlevini degrade iniş veya hücresel algoritma kullanarak x1'den x ^ n_m'ye kadar bir işlev olarak en aza indirirseniz, bu aslında iyi özellikleri öğrenmede oldukça iyi bir tahminde bulunmanıza olanak tanır. filmler için. Bu, özelliklerin harici olarak verilmesi gereken çoğu makine öğrenimi uygulaması için oldukça dikkat çekicidir, ancak bu algoritmada, belirli bir filmin özelliklerini gerçekten öğrenebiliriz. Ancak bu videoda şimdiye kadar yaptıklarımız, farklı kullanıcılar için w ve b parametrelerine sahip olduğunuzu varsaydık. Bu parametreleri nereden alıyorsunuz? Pekala, w ve b'yi öğrenmek için son videodaki algoritmayı ve x'i öğrenmek için bu videoda az önce bahsettiğimiz şeyi bir araya getirelim ve bu bize işbirliğine dayalı filtreleme algoritmamızı verecektir. İşte özellikleri öğrenmek için maliyet işlevi. Bu son slaytta elde ettiğimiz şeydi. Şimdi, bu ikisini bir araya getirirsek, buradaki bu terimin buradaki terimle tamamen aynı olduğu ortaya çıktı. I'in tüm değerlerinin j üzerindeki toplamının, r, i, j'nin 1'e eşit olması, r, i, j'nin 1'e eşit olduğu tüm j ile i'nin tüm değerlerinin toplanmasıyla aynı olduğuna dikkat edin. Bu özet, derecelendirmenin olduğu tüm kullanıcı film çiftlerini özetlemektedir. Yapacağım şey, bu iki maliyet fonksiyonunu bir araya getirmek ve toplamı daha açık bir şekilde tüm ı ve j çiftlerinin toplamı olarak yazdığım yere sahip olmak, burada her zamanki kare maliyet fonksiyonunun bir derecesine sahibiz ve sonra w parametrelerini öğrenmekten düzenleme terimini almama izin verin ve b, ve bunu buraya koyun ve x özelliklerini öğrenmekten düzenlilik terimini alın ve buraya koyun ve bu, w, b ve x'i öğrenmek için toplam maliyet fonksiyonumuz olur. Bu maliyet fonksiyonunu w ve b'nin y olarak x olarak bir fonksiyonu olarak en aza indirirseniz, bu algoritmanın gerçekten işe yaradığı ortaya çıkıyor. Demek istediğim şu. Üç kullanıcımız ve iki filmimiz olsaydı ve bu dört film için derecelendirmeleriniz varsa, ancak bu ikisi için değilse, burada, tüm kullanıcılar üzerindeki toplamlar. Kullanıcı 1 için bunun maliyet fonksiyonunu, kullanıcı 2 için bunun maliyet fonksiyonunu, kullanıcı 3 için bunun maliyet fonksiyonunu belirlemiştir. Önce kullanıcıları topluyoruz ve ardından derecelendirmenin olduğu her film için bir dönem geçiriyoruz. Ancak toplamı gerçekleştirmenin alternatif bir yolu, önce film 1'e bakmaktır, buradaki toplamın yaptığı budur ve ardından film 1'i derecelendiren tüm kullanıcıları dahil etmek ve ardından film 2'ye bakmak ve tüm kullanıcılar için bir terime sahip olmaktır. film 2'yi derecelendirmişti. Her iki durumda da, kullanıcının ilgili filmi derecelendirdiği bu dört alanı özetlediğimizi görüyorsunuz. Bu yüzden üstteki bu özet ve buradaki bu özet, kullanıcının o filmi derecelendirdiği tüm çiftleri özetlemenin iki yoludur. Bu maliyet fonksiyonunu w, b ve x'in bir fonksiyonu olarak nasıl en aza indirirsiniz? Yapabileceğiniz bir şey degrade iniş kullanmaktır. Ders 1'de doğrusal regresyonu öğrendiğimizde, bu gördüğünüz gradyan iniş algoritmasıdır, burada w ve b parametrelerinin bir fonksiyonu olan J maliyet fonksiyonuna sahiptik ve gradyan inişini aşağıdaki gibi uygulardık. İşbirlikçi filtreleme ile maliyet işlevi yalnızca w işlevindedir ve b artık w, b ve x'in bir işlevidir. Burada tüm kullanıcıların parametrelerini belirtmek için w ve b kullanıyorum ve burada x, tüm filmlerin özelliklerini belirtmek için gayri resmi olarak. Ancak, farklı parametrelere göre kısmi türevler alabiliyorsanız, parametreleri aşağıdaki gibi güncellemeye devam edebilirsiniz. Ama şimdi bunu x'e göre de optimize etmemiz gerekiyor. Ayrıca bu parametrelerin her birini güncellemek isteyeceğiz x aşağıdaki gibi gradyan inişini kullanarak. Bunu yaparsanız, aslında x'in yanı sıra w ve b'nin oldukça iyi değerlerini bulduğunuz ortaya çıkıyor. Sorunun bu formülasyonunda, w ve b ve x parametreleri de bir parametredir. Son olarak, x'in değerlerini öğrenmek için, x'i x eksi w, b, x maliyetinin x'e göre kısmi türevi olarak güncelleyeceğiz. Buradaki gösterimi biraz gayri resmi olarak kullanıyorum ve üst simgeleri ve alt simgeleri çok dikkatli takip etmiyorum, ancak anahtar paket servisi olan restoran, x, b, x, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, bundan, bu modelin parametrelerinin w ve b olduğunu ve x'in de artık bir parametre olduğunu umuyoruz, bu nedenle bu parametre kümelerinin üçünün de bir fonksiyonu olarak maliyet işlevini en aza indiriyoruz, w ve b, hem de x. Elde ettiğimiz ortalamaya işbirliğine dayalı filtreleme denir ve işbirliğine dayalı filtreleme adı, birden fazla kullanıcının aynı filmi ortak olarak derecelendirmesi nedeniyle, bu filmin neye benzediğine dair bir fikir verdiğinizde, bunun için uygun özelliklerin neler olduğunu tahmin etmenizi sağladığı anlamına gelir. o film için ve bu da sizin için uygun özelliklerin ne olduğunu tahmin etmenizi sağlar. aynı filmi henüz derecelendirmemiş diğer kullanıcıların gelecekte nasıl derecelendirmeye karar verebileceğini tahmin edin. Bu işbirliğine dayalı filtreleme, birden çok kullanıcıdan gelen verilerin toplanmasıdır. Kullanıcılar arasındaki bu işbirliği, gelecekte diğer kullanıcılar için bile derecelendirmeleri tahmin etmenize yardımcı olur. Şimdiye kadar, problem formülasyonumuz 1- 5 yıldız veya 0- 5 yıldız arasında film derecelendirmeleri kullandı. Önerilen sistemlerin çok yaygın bir kullanım durumu, kullanıcının tercih ettiği veya beğendiği veya bir öğeyle etkileşime girdiği ikili etiketlere sahip olmanızdır. Bir sonraki videoda, şimdiye kadar gördüğünüz modelin ikili etiketlere genellemesine bir göz atalım. Bunu bir sonraki videoda görelim.

## Binary labels: favs, likes and clicks
Önerilen sistemlerin veya toplu filtreleme algoritmalarının birçok önemli uygulaması, bir kullanıcının size bir ila beş yıldız veya sıfırdan beş yıldıza derecelendirme vermesi yerine, bir şekilde size bu öğeyi beğendikleri veya beğenmedikleri hissini verdikleri ikili etiketleri içeriyordu. bu öğe. Bu ayarda gördüğünüz algoritmanın nasıl genelleştirileceğine bir göz atalım. Algoritmayı genelleştirmek için kullanacağımız süreç, doğrusal regresyondan lojistik regresyona, sayıları tahmin etmeye ve ikili bir etiketi tahmin etmeye nasıl gittiğimizi çok anımsatacaktır. İşte ikili etiketlerle birlikte çalışan bir filtreleme veri kümesine bir örnek. Bir kullanıcının belirli bir filmi beğendiği veya onunla ilgilendiği notlar. Bu yüzden etiket bir, Alice'in sonunda Aşk filmini sonuna kadar izlediği ve romantizmi sonsuza dek sonuna kadar izlediği anlamına gelebilir. Ancak birkaç dakika kesintisiz araba kovalamacası oynadıktan sonra videoyu durdurmaya ve devam etmeye karar verdi. Ya da bu filmleri beğendiğini belirtmek için bir uygulamada açıkça beğen veya favori'ye vurduğu anlamına gelebilir. Ama durmadan kontrol ettikten sonra bulut avcıları ve kılıçlara karşı karate gibi vurmadı. Ve soru işareti genellikle kullanıcının öğeyi henüz görmediği anlamına gelir ve bu nedenle o öğeye beğen veya sık kullanılana basıp basmamaya karar verecek konumda değillerdi. Öyleyse soru şu ki, son videoda gördüğünüz işbirlikçi filtreleme ortalamasını nasıl alabilir ve bu daaset üzerinde çalışmasını sağlayabiliriz. Alice, Bob carol ve Dave'in henüz derecelendirmedikleri öğeleri beğenme olasılıklarını tahmin ederek, bu öğeleri onlara ne kadar tavsiye etmemiz gerektiğine karar verebiliriz. Birinci etiketin ne olduğunu ve sıfır etiketinin ne olduğunu ve ikili etiketlerle işbirliğine dayalı filtrelemede etiket soru işaretinin ne olduğunu tanımlamanın birçok yolu vardır. Birkaç örneğe bir göz atalım. Bir çevrimiçi alışveriş web sitesinde etiket, müziğe maruz kaldıktan sonra, öğeyi gösterdikten sonra bir öğeyi satın almayı seçip seçmediklerini gösterebilir. Yani biri onu satın aldıklarını gösterir sıfır, satın almadıklarını gösterir. Ve soru işareti, gösterilmediklerini, öğeye bile maruz kalmadıklarını gösterecekti. Veya bir sosyal medya ortamında, bir veya sıfır etiketleri, kullanıcının bir öğeyi gösterildikten sonra beğendiğini veya beğendiğini gösterebilir. Ve soru işareti, henüz bir öğe gösterilmediyse veya açık bir kullanıcı derecelendirmesi istemek yerine birçok site, kullanıcının öğeyi beğenip beğenmediğini tahmin etmeye çalışmak için kullanıcı davranışını kullanacaktır. Örneğin, bir kullanıcının bir öğenin en az 30 saniyesini harcayıp harcamadığını ölçebilirsiniz. Ve eğer yaptılarsa, kullanıcı öğeyi ilgi çekici bulduğu için veya bir kullanıcıya bir öğe gösterildiyse ancak onunla en az 30 saniye geçirmediyse, o zaman bir etiketin sıfır olduğuna dair bir işaret verin. Veya kullanıcıya öğe henüz gösterilmediyse, ona bir soru işareti atayın. Kullanıcı davranışının bir işlevi olarak örtük olarak bir derecelendirme oluşturmanın başka bir yolu, kullanıcının bir öğeye tıkladığını görmek olacaktır. Bu genellikle, kullanıcıya bir reklam gösterildiyse, üzerine tıkladıysa emeğe atanan, sıfır etiketine atanmamışsa ve kullanıcıya o reklam ilk etapta gösterilmemişse soru işaretine atıfta bulunulduğu çevrimiçi reklamcılıkta yapılır. Çoğu zaman bu ikili etiketlerin kaba bir anlamsız takipleri olacaktır. Birinin emeği, bir öğe gösterildikten Ve nişanlandıktan sonra nişanlanan kullanıcının tıkladığı veya 30 saniye harcadığı veya öğeyi açıkça sevdiği veya satın almak istediği anlamına gelebileceği anlamına gelir. Sıfır, öğeyi gösterdikten sonra kullanıcının katılmadığını yansıtır, soru işareti henüz kullanıcıya gösterilmemiş öğeyi yansıtır. Bu ikili etiketler göz önüne alındığında, önceki çift videolardan bu ikili çıktıları tahmin etmeye kadar doğrusal regresyona çok benzeyen algoritmamızı nasıl genelleyebileceğimize bakalım. Daha önce yij etiketini wj olarak tahmin ediyorduk.xi + b. Yani bu doğrusal bir regresyon modeline çok benziyordu. İkili etiketler için, yijb = 1 olasılığının wj değil tarafından verildiğini tahmin edeceğiz.xı+b. Fakat bu formülün g'si ile, şimdi -z'ye g (z) 1/1 + e olduğumuzu söyledi. Yani bu, lojistik regresyonda gördüğümüz gibi lojistik fonksiyondur. Ve yapacağımız şey, doğrusal bir regresyon modeline çok benzeyen şeyi almak ve onu lojistik regresyon modeline çok benzeyen bir şeye dönüştürmek, burada şimdi yij'in 1 olma olasılığını tahmin edecek, yani kullanıcının bu modeli kullanan öğeyle meşgul olması veya beğenmesi. Bu algoritmayı oluşturmak için, maliyet işlevini kare hata maliyet işlevinden, model gibi bir lojistik regresyon için ikili etiketler için daha uygun olan maliyet işlevine de değiştirmemiz gerekecek. Yani daha önce, bu terimin algoritmanın tahmini olan f (x) 'e benzer rollerini oynadığı yerde sahip olduğumuz maliyet fonksiyonu buydu. Artık ikili etiketleriniz olduğunda, yij etiketler bir veya sıfır olduğunda veya soru işareti olduğunda, tahmin wj yerine f (x) olur.xi + b j bunun g'si olur, burada g lojistik fonksiyondur. Lojistik regresyonu türettiğimiz zamana benzer şekilde, algoritma f (x) 'i tahmin ederse ve gerçek etiket y ise, kayıp olan tek bir örnek için aşağıdaki kayıp fonksiyonunu yazmıştık, kayıp şuydu. Öyleydi -y günlüğü f-y günlüğü 1-f. Buna bazen ikili çapraz entropi maliyet fonksiyonu da denir. Ancak bu, sinir ağlarını eğitirken ikili sınıflandırma problemlerinde olduğu gibi lojistik regresyon için kullandığımız standart bir maliyet fonksiyonudur. Ve bunu işbirliğine dayalı filtreleme ayarına uyarlamak için, şimdi tüm w ve b parametrelerinin yanı sıra tek tek filmlerin veya öğelerinin özellikleri olan tüm x parametrelerinin bir işlevi olan maliyet işlevini yazmama izin verin. Şimdi, riij = 1'in bunun üstteki toplamla aynı olduğunu fark ettiği tüm ıj çiftlerinden bazılarına ihtiyacımız var. Ve şimdi bu karesel hata maliyet fonksiyonu yerine, bu kayıp fonksiyonunu kullanacağız. F (x) 'in bir fonksiyonu var, yij. Burada f (x) nerede? Bu benim kısaltmam. G (w) j.x1 + ej için kısaltmam. Bunu buraya taktığımızda, bu size ikili etiketlerde işbirliğine dayalı filtreleme için kullanabilecekleri maliyet işlevini verir. Demek bu kadar. İşbirlikçi filtreleme algoritması gibi doğrusal regresyonu bu şekilde alabilir ve ikili etiketlerle çalışacak şekilde genelleştirebilirsiniz. Ve bu aslında bu algoritma ile ele alabileceğiniz uygulama kümesini çok önemli ölçüde açar.
Şimdi, algoritmanın temel yapısını ve maliyet işlevini görmüş olsanız da, algoritmanızın çok daha iyi çalışmasını sağlayacak bazı ipuçları da var. Nasıl uyguladığınıza dair bazı ayrıntılara ve albümün çok daha hızlı çalışmasını sağlayan bazı küçük değişikliklere göz atmak için bir sonraki videoya geçelim. Bir sonraki videoya geçelim.

## Mean normalization
İlk derste, doğrusal regresyon için gelecekteki normalleşmenin algoritmanın daha hızlı çalışmasına nasıl yardımcı olabileceğini gördünüz. Bir ila beş veya sıfırdan beş yıldıza kadar film derecelendirmeleri gibi geniş sayılara sahip önerilen bir sistem oluşturulması durumunda, algoritmanızın daha verimli çalışacağı ortaya çıkar. Ayrıca, önce ortalama normalleştirme yaparsanız biraz daha iyi performans gösterin. Yani, film derecelendirmelerini tutarlı bir ortalama değere sahip olacak şekilde normalleştirirseniz, bunun ne anlama geldiğine bir göz atalım. İşte kullandığımız veri seti. Ve aşağıda, modelin parametrelerini öğrenmek için kullandığınız maliyet işlevi bulunmaktadır. Ortalama normalleşmeyi açıklamak için, henüz herhangi bir filmi derecelendirmemiş beşinci kullanıcı Havva'yı ekleyeceğim. Ve birazcık, ortalama normalleştirme eklemenin algoritmanın kullanıcı Arifesinde daha iyi tahminler yapmasına yardımcı olacağını görüyorsunuz. Aslında, bu veriler üzerinde işbirliğine dayalı bir filtreleme algoritması geliştirecek olsaydınız, o zaman bu düzenleme terimi nedeniyle w parametrelerini küçük yapmaya çalıştığımız için. Algoritmayı bu veri kümesinde çalıştıracak olsaydınız, aslında beşinci kullanıcı için w parametreleriyle sonuçlanırsınız, böylece kullanıcı Arifesi [0 0] 'a eşit olur ve büyük olasılıkla b (5) = 0 olur. Eve henüz hiçbir filmi derecelendirmediği için, w ve b parametreleri maliyet işlevindeki bu ilk terimi etkilemez çünkü Eve'in filminin derecelendirmesinin hiçbiri bu kare hata maliyet işlevinde rol oynamaz. Ve böylece bunu en aza indirmek, w parametrelerini mümkün olduğunca küçük yapmak anlamına gelir. Ancak b'yi varsayılan olarak 0 olarak başlatırsanız, b (%) = 0 ile sonuçlanırsınız. Ancak bunlar, Havva için olan kullanıcı 5'in parametreleriyse, ortalamanın yapacağı şey, Havva'nın tüm film derecelendirmelerinin w (%) olacağını tahmin etmektir.ı + b (5) filmi için x. Ve yukarıdaki w ve b 0'a eşitse bu 0'a eşittir. Ve böylece bu algoritma, henüz hiçbir şeyi derecelendirmemiş yeni bir kullanıcınız varsa, tüm filmleri sıfır yıldızla derecelendireceklerini düşünüyoruz ve bu özellikle umut verici değil. Bu videoda, ortalama normalleşmenin, bu algoritmanın henüz herhangi bir filmi derecelendirmemiş yeni bir kullanıcı için film derecelendirmelerinin daha iyi tahminlerini oluşturmasına yardımcı olacağını göreceğiz. Ortalama normalleşmeyi tanımlamak için, Eve için tüm soru işaretleri de dahil olmak üzere buradaki tüm değerleri alıp şöyle iki boyutlu bir matrise koymama izin verin. Sadece soru işaretleri de dahil olmak üzere tüm derecelendirmeleri daha sürdürülebilir ve daha kompakt bir şekilde yazmak için. Ortalama normalleşmeyi gerçekleştirmek için yapacağımız şey tüm bu derecelendirmeleri almak ve her film için verilen ortalama derecelendirmeyi hesaplamak. Yani birinci filmin iki 5'i ve iki 0'ı vardı ve bu nedenle ortalama derecelendirme 2.5'tir. İkinci filmde 5 ve 0 vardı, bu yüzden ortalama 2,5'e çıktı. Üçüncü film 4 ve 0 ortalamaları 2'ye çıkıyor. Dördüncü film ortalama 2,25 reytinge çıkıyor. Ve beşinci film o kadar popüler değil, ortalama 1.25 reytinge sahip. Bu yüzden bu beş sayının hepsini alıp μ olarak adlandıracağım bir vektöre toplayacağım çünkü bu, filmlerin her birinin sahip olduğu ortalama derecelendirmelerin vektörüdür. Sadece o filmi okuyan kullanıcıların ortalaması alınır. Buradaki orijinal 0 ila 5 yıldızlı derecelendirmeleri kullanmak yerine, bunu alacağım ve her derecelendirmeden verilen ortalama derecelendirmeyi çıkaracağım. Örneğin, bu film derecelendirmesi 5 idi. 2.5'i çıkaracağım ve bana 2.5 vereceğim. Bu film 0 yıldız derecelendirmesine sahipti. Yeni kullanıcı Arifesi de dahil olmak üzere şu anda beş kullanıcının tümü ve beş filmin tümü için bana -2.25 puan veren 2.25'i çıkaracağım. Sonra sağdaki bu yeni değerler sizin yeni Y (i, j) değerleriniz olur. Kullanıcı 1'in birinci filme 2,5 puan verdiğini ve dördüncü filme -2,25 puan verdiğini iddia edeceğiz. Ve bunu kullanarak, daha önce olduğu gibi w (j), b (j) ve x (i) 'yi öğrenebilirsiniz. filmdeki j kullanıcısı için, w (j) 'yi tahmin edersiniz.x(ı) + b(j). Ancak, 0'dan 5 yıldıza kadar kullanıcı oranları için imkansız olan negatif bir yıldız derecelendirmesini tahmin etmemek için bu ortalama normalleştirme adımı sırasında film ı için µı'yi çıkardığımız için. Çıkardığımız değer olan bu µı'yi geri eklemeliyiz. Somut bir örnek olarak, henüz herhangi bir filmi derecelendirmediği için yeni kullanıcı Eve ile kullanıcı 5'e ne olduğuna bakarsak, ortalama w (5) = [0 0] parametrelerini öğrenebilir ve b (5) = 0 diyebilir. Ve böylece birinci film için öngörülen derecelendirmeye bakarsak, Havva'nın bunu w (5) olarak değerlendireceğini tahmin edeceğiz.x1 + b (5) ama bu 0 ve sonra + µ1, 2.5'e eşittir. Bu nedenle, Havva'nın henüz herhangi bir filmi derecelendirmediği için tüm film sıfır yıldızlarını derecelendireceğini düşünmek yerine, Havva'nın bu filmi 2,5 olarak derecelendireceğini düşünmek daha mantıklı görünüyor. Ve aslında bu algoritmanın etkisi, yeni kullanıcı Eve için ilk tahminlerin, diğer kullanıcıların bu beş filmi derecelendirdiği her şeyin ortalamasına eşit olmasına neden olacağıdır. Ve bu, Havva'nın tüm reytinglerinin sıfır olacağını tahmin etmek yerine, filmlerin ortalama reytingini almak daha mantıklı görünüyor. Farklı film derecelendirmelerinin ortalamasının sıfır olması normalleştirilerek, önerilen sistem için optimizasyon algoritmasının da biraz daha hızlı çalışacağı ortaya çıktı. Ancak bu, algoritmanın hiçbir filmi veya çok az sayıda filmi derecelendirmemiş kullanıcılar için çok daha iyi davranmasını sağlar. Ve tahminler daha makul hale gelecektir. Bu örnekte, yaptığımız şey, bu matrisin her satırını sıfır ortalamaya sahip olacak şekilde normalleştirmekti ve bunun, henüz çok fazla film derecelendirmemiş yeni bir kullanıcı olduğunda yardımcı olduğunu gördük. Kullanabileceğiniz başka bir alternatif var, bunun yerine bu matrisin sütunlarını sıfır ortalamaya sahip olacak şekilde normalleştirmek. Ve bu da makul bir şey olurdu. Ancak bu uygulamada, yeni bir kullanıcı için makul derecelendirmeler verebilmeniz için satırları normalleştirmenin sütunları normalleştirmekten daha önemli göründüğünü düşünüyorum. Sütunları normalleştirmek, henüz kimsenin derecelendirmediği yepyeni bir film olsaydı umut olurdu. Ancak henüz kimsenin derecelendirmediği yepyeni bir film varsa, muhtemelen o filmi başlangıçta çok fazla kullanıcıya göstermemelisiniz çünkü o film hakkında o kadar fazla şey bilmiyorsunuz. Bu nedenle, derecelendirmesiz bir film örneğinde umudun sütunlarını normalleştirmek, henüz hiç film derecelendirmemiş yeni bir kullanıcı örneğinde umudun kurallarını normalleştirmekten daha az önemli görünüyor. Ve bu haftaki uygulama laboratuvarında kendi önerilen sisteminizi oluştururken, yalnızca rolleri normalleştirmek iyi sonuç vermelidir. Yani bu normalleşme demek. Algoritmanın biraz daha hızlı çalışmasını sağlar. Ancak daha da önemlisi, çok az filmi derecelendiren, hatta hiç filmi derecelendirmeyen kullanıcılar olduğunda algoritmanın çok daha iyi, çok daha makul tahminler vermesini sağlar. Ortalama normalleşmenin bu uygulama detayı, önerilen sisteminizin çok daha iyi çalışmasını sağlayacaktır. Ardından, bunu kendiniz için nasıl uygulayabileceğiniz hakkında konuşmak için bir sonraki videoya geçelim. yoğun akış.


## TensorFlow implementation of collaborative filtering
Neden bu şekilde yapmak zorunda olduğumuzu merak ediyorsanız? Neden yoğun bir katman ve ardından model derleyici ve model uyumu kullanamadık? Bu eski tarifi kullanamamamızın nedeni, teminat filtreleme algoritması ve maliyet işlevinin yoğun katmana veya TensorFlow'un diğer standart sinir ağı katmanı türlerine tam olarak uymamasıdır. Bu nedenle, maliyet fonksiyonunu kendimiz uygulayacağımız başka bir şekilde uygulamak zorunda kaldık. Ancak daha sonra, Otomatik Fark olarak da adlandırılan otomatik farklılaştırma için TensorFlow'un araçlarını kullanın. Ve maliyet işlevini optimize etme işinin çoğunu bizim için yapmasına izin vermek için TensorFlow'un adam optimizasyon algoritması uygulamasını kullanın. Sahip olduğunuz model, yoğun sinir ağı katmanları dizisi veya TensorFlow tarafından desteklenen diğer katman türleriyse ve model bileşik model uyumunun eski uygulama tarifi işe yarıyorsa. Ancak böyle olmadığında bile, TensoFlow'un bu araçları size diğer öğrenme algoritmalarını da uygulamanız için çok etkili bir yol sunar.
Bu videoda, işbirliğine dayalı filtreleme algoritmasını uygulamak için Tensorflow'u nasıl kullanabileceğinize bir göz atacağız. Tensorflow'u sinir ağları oluşturmak için bir araç olarak düşünmeye alışkın olabilirsiniz. Ve öyle. Sinir ağları oluşturmak için harika bir araçtır. Ve Tensorflow'un başka tür öğrenme algoritmaları oluşturmak için de çok umutlu olabileceği ortaya çıktı. İşbirlikçi filtreleme algoritması gibi. Bu tür konuşmalar için Tensorflow'u kullanmayı sevmemin nedenlerinden biri, gradyan inişini uygulamak için birçok uygulama için maliyet fonksiyonunun türevlerini bulmanız gerektiğidir, ancak TensorFlow sizin için maliyet fonksiyonunun türevlerinin ne olduğunu otomatik olarak anlayabilir. Tek yapmanız gereken maliyet fonksiyonunu uygulamak ve herhangi bir hesaplamaya ihtiyaç duymadan, türevleri kendiniz almanıza gerek kalmadan, maliyet fonksiyonunu optimize etmek için kullanılabilecek türev terimini hesaplamak için sadece birkaç satır kodla TensorFlow elde edebilirsiniz. Tüm bunların nasıl çalıştığına bir göz atalım. Sağdaki bu diyagramı birinci dersten hatırlayabilirsiniz. Bu tam olarak w'yi optimize etmekten bahsettiğimizde baktığımız diyagramdır. İlk doğrusal regresyon örneğimiz üzerinde çalışırken. Ve o zaman b = 0'ı ayarlamıştık. Ve böylece model sadece f (x) = w.x'i tahmin ediyordu Ve maliyet fonksiyonunu en aza indiren w değerini bulmak istedik J. Bunu yaptığımız yol, şuna benzeyen bir gradyan iniş güncellemesiydi, burada w, w eksi öğrenme olarak tekrar tekrar güncellenir alfa çarpı türev terimini değerlendirin. B'yi de güncelliyorsanız, kullanacağınız ifade budur. Ancak b = 0 dediyseniz, ikinci güncellemeden vazgeçersiniz ve bu degrade iniş güncellemesini yakınsamaya kadar gerçekleştirmeye devam edersiniz. Bazen bu türev veya kısmi türev terimini hesaplamak zor olabilir. Ve Tensorflow'un bu konuda yardımcı olabileceği ortaya çıktı. Bakalım nasıl olacak. Çok basit bir maliyet fonksiyonu kullanacağım J = (wx-1) kare. Yani wx bizim basitleştirilmiş f w x'imizdir ve y eşittir 1'dir. Ve eğer sahip olduğumuz bir eğitim örneği için f (x) eşittir wx, y eşittir 1 olsaydı ve bunu b'ye göre optimize etmeseydik, bu maliyet fonksiyonu olurdu. Yani gradyan iniş algoritması, bu güncellemeyi burada yakınsamaya kadar tekrar edecektir. Burada J maliyet fonksiyonunu uygularsanız, TensorFlow sizin için bu türev terimi otomatik olarak hesaplayabilir ve böylece degrade inişini çalıştırabilir. Size bu kodun ne yaptığına dair üst düzey bir genel bakış vereceğim, w = tf.değişken (3.0). W parametresini alır ve 3.0değerine başlatır. Tensorflow'a w'nin bir değişken olduğunu söylemek, ona w'nin optimize etmek istediğimiz bir parametre olduğunu nasıl söylediğimizdir. X = 1.0, y = 1.0 ve öğrenme hızı alfa'yı 0.01'e eşit olacak şekilde ayarlayacağım. Ve 30 yineleme için gradyan muhalefetini çalıştıralım. Yani bu kodda, aralık yinelemelerinde ıter için, yani 30 yineleme için hala geçerli olacaktır. Ve bu, Tensorflow'un rotorları sizin için otomatik olarak hesaplamasını sağlayan sözdizimidir. TensorFlow, degrade bant adı verilen bir özelliğe sahiptir. Ve bunu tf ile yazarsanız, gradyan bandımız f bandı olarak. Bu, f (x) 'i w * x olarak hesaplayın ve J'yi f (x) -y karesi olarak hesaplayın. Ardından, Tensorflow'a costj'ye nasıl hesaplanacağını söyleyerek ve bunu aşağıdaki gibi degrade bantlanmış sözdizimi ile yaparak, TensorFlow adım dizisini otomatik olarak kaydeder. Maliyeti hesaplamak için gereken işlem dizisij. Ve bu otomatik farklılaşmayı sağlamak için gereklidir. Sonraki TensorFlow, işlem sırasını bantta, degrade bantta kaydetmiş olacaktır. Ve bu sözdizimi ile TensorFlow, dJdw olarak adlandıracağım bu türev terimi otomatik olarak hesaplayacaktır. Ve TensorFlow, saygın w türevini almak istediğinizi biliyor. Bu w, optimize etmek istediğiniz parametredir, çünkü bunu burada söylemiştiniz. Ve burada da belirttiğimiz için. Yani şimdi bilgisayar türevleri, nihayet bu güncellemeyi w'yi alarak ve ondan öğrenme oranını çıkararak gerçekleştirebilirsiniz. alfa Yukarıdan yeni aldığımız türev terimin çarpı. TensorFlow değişkenleri, katman değişkenleri özel işlem gerektirir. Bu nedenle, w'yi normal şekilde türevin w eksi alfa çarpı olarak ayarlamak yerine, bu atanmış ekleme işlevini kullanırız. Ama muayenehaneye gittiğin zaman endişelenme. Teminat filtreleme algoritmasını doğru bir şekilde uygulamak için ihtiyacınız olan tüm sözdizimini size vereceğiz. Bu nedenle, Tensorflow'un gradyan bant özelliği ile yapmanız gereken ana işin, maliyet fonksiyonunun nasıl hesaplanacağını söylemek olduğuna dikkat edin. J. Ve sözdiziminin geri kalanı, Tensorflow'un sizin için bu türevin ne olduğunu otomatik olarak anlamasına neden olur mu? Ve bu TensorFlow ile bunun eğimini bu tire çizgisiyle gösterilen 3'te bularak başlayacağız. Bir gradyan adımı atın ve w'yi güncelleyin ve türevi tekrar hesaplayın ve sonunda w eşittir 1 olan en uygun w değerine ulaşana kadar w'yi tekrar tekrar güncelleyin. Dolayısıyla bu prosedür, bu türev terimini nasıl hesaplayacağınızı kendiniz bulmak zorunda kalmadan gradyan inişini uygulamanıza olanak tanır. Bu, Tensorflow'un Auto Diff adlı çok güçlü bir özelliğidir. Pytorch gibi diğer bazı makine öğrenimi paketleri de Otomatik Farkı destekler. Bazen insanların buna Auto Grad dediğini duyarsınız. Teknik olarak doğru terim Auto Diff'dir ve Auto Grad aslında türevleri otomatik olarak almak için otomatik farklılaşma yapmak için belirli yazılım paketinin adıdır. Ancak bazen birisinin Otomatik Mezuniyete atıfta bulunduğunu duyarsanız, sadece aynı türevleri otomatik olarak alma kavramına atıfta bulunurlar. Öyleyse bunu ele alalım ve Auto Diff kullanarak işbirliğine dayalı filtreleme algoritmasına nasıl uygulayabileceğinize bakalım. Ve aslında, türevleri otomatik olarak hesaplayabildiğinizde, sadece gradyan inişiyle sınırlı kalmazsınız. Adam optimizasyon algoritması gibi daha güçlü bir optimizasyon algoritması da kullanabilirsiniz. İşbirliğine dayalı filtreleme algoritması Tensorflow'u uygulamak için kullanabileceğiniz sözdizimi budur. Optimizatörün keras optimizers adam olduğunu ve burada belirtilen öğrenme hızına sahip olduğunu belirterek başlayalım. Ve sonra diyelim ki, 200 yineleme, işte sözdizimi tf gradyan bandı, s bandı ile daha önce olduğu gibi, maliyet fonksiyonunun değerini hesaplamak için kod sağlamanız gerekir. Bu nedenle, işbirliğine dayalı filtrelemede, J'nin aldığı maliyet fonksiyonunun, x, w ve b giriş parametrelerinin yanı sıra derecelendirmelerin normalize edildiği anlamına geldiğini hatırlayın. Bu yüzden yazıyorum y normu, r (i, j) hangi değerlerin derecelendirmeye sahip olduğunu, gösterimimizde kullanıcı sayısını veya nu'yu, gösterimimizde film sayısını veya nm'yi veya sadece num'u ve düzenleme parametresini belirterek lambda. Ve eğer bu maliyet fonksiyonunu uygulayabilirseniz J, o zaman bu sözdizimi Tensorflow'un sizin için türevleri bulmasına neden olur. Ardından bu sözdizimi, Tensorflow'un maliyeti hesaplamak için kullanılan işlem sırasını kaydetmesine neden olur. Ve sonra size not vermesini isteyerek kasete eşittir.gradyan, bu size maliyet fonksiyonunun x, w ve b'ye göre türevini verecektir. Ve son olarak, adam optimizer olarak üstte belirttiğimiz optimizer ile. Optimize ediciyi az önce hesapladığımız degradelerle kullanabilirsiniz. Ve python'da işlev görüyor mu, sayıları uygulanan degradeler işlevi için uygun bir sıraya göre yeniden düzenleyen bir işlevdir. Teminat filtrelemesi için gradyan alçalması kullanıyorsanız, maliyet fonksiyonunun J , w, b ve x'in bir fonksiyonu olacağını hatırlayın. Ve eğer gradyan inişi uyguluyorsanız, kısmi türevi w'ye göre alırsınız. Ve sonra w'yi aşağıdaki gibi güncelleyin. Ve ayrıca bu sayının kısmi türevini b'ye alırsınız. Ve b'yi aşağıdaki gibi güncelleyin. Ve benzer şekilde x özelliklerini aşağıdaki gibi güncelleyin. Ve yakınlaşana kadar tekrar edersiniz. Ancak TensorFlow ve Auto Diff ile daha önce de belirttiğim gibi, sadece gradyan inişiyle sınırlı değilsiniz. Adam optimizer gibi daha güçlü bir optimizasyon algoritması da kullanabilirsiniz. Uygulama laboratuarında kullandığınız veri seti, gerçek kişiler tarafından derecelendirilen gerçek filmlerden oluşan gerçek bir veri setidir. Bu film objektifi veri seti ve Harper ve Konstan'dan kaynaklanıyor. Umarım bu algoritmayı gerçek bir film ve derecelendirme veri kümesinde çalıştırmaktan zevk alırsınız ve bu algoritmanın elde edebileceği sonuçları kendiniz görürsünüz. Demek bu kadar. İşbirlikçi filtreleme algoritmasını Tensorflow'da bu şekilde uygulayabilirsiniz. Neden bu şekilde yapmak zorunda olduğumuzu merak ediyorsan? Neden yoğun bir katman kullanamadık ve sonra model derleyici ve model sığdırılamadı? Bu eski tarifi kullanamamamızın nedeni, teminat filtreleme algoritması ve maliyet işlevi, yoğun katmana veya diğer standart sinir ağı katmanı TensorFlow türlerine düzgün bir şekilde uymuyor.
Bu yüzden bunu maliyet işlevini kendimiz uygulayacağımız başka bir şekilde uygulamak zorunda kaldık. Ancak daha sonra Otomatik Fark olarak da adlandırılan otomatik farklılaşma için tensorflow'un araçlarını kullanın. Ve Tensorflow'un adam optimizasyon algoritmasını uygulamasını kullanarak maliyet fonksiyonunu optimize etmemizdeki birçok işi yapmasına izin verin. Sahip olduğunuz model, yoğun sinir ağı katmanları dizisi veya TensorFlow tarafından desteklenen diğer katman türleriyse ve model compound model fit'in eski uygulama tarifi işe yararsa. Ancak olmasa bile, bu araçlar TensoFlow size diğer öğrenme algoritmalarını da uygulamak için çok etkili bir yol sunar. Umarım bu haftaki uygulama laboratuvarındaki teminat filtreleme alıştırmasıyla daha çok oynamaktan zevk alırsınız. Ve çok fazla kod ve çok fazla sözdizimi var gibi görünüyor, endişelenmeyin. Bu egzersizi başarıyla tamamlamak için ihtiyacınız olana sahip olduğunuzdan emin olun. Ve bir sonraki videoda, teminat filtrelemenin nüanslarını ve özellikle bir film verildiğinde, buna benzer başka filmler olup olmadığına ilişkin ilgili öğeleri nasıl bulacağınız sorusunu daha fazla tartışmak istiyorum. Bir sonraki videoya geçelim.


## Finding related items
işbirlikçi filtrelemenin birkaç sınırlamasından bahsetmek istiyorum. İşbirlikçi filtrelemede, bir dizi öğeniz vardır ve bu nedenle kullanıcılar ve kullanıcılar bazı öğe alt kümelerini derecelendirmiştir. Bu zayıflıklardan biri, soğuk çalıştırma probleminde pek iyi olmamasıdır. Örneğin, kataloğunuzda yeni bir ürün varsa, diyelim ki birisi yeni bir film yayınladı ve bu filme neredeyse hiç kimse oy vermedi, daha önce çok az kullanıcı oy verdiyse, yeni öğeyi nasıl sıralarsınız? Benzer şekilde, yalnızca birkaç öğeyi değerlendiren yeni kullanıcılar için onlara makul bir şey gösterdiğimizden nasıl emin olabiliriz? Daha önceki bir videoda, normalleşmenin bu konuda nasıl yardımcı olabileceğini ve çok yardımcı olduğunu görebilirdik. Ancak, çok az öğeyi derecelendiren kullanıcılara ilgilerini çekebilecek şeyleri göstermenin daha da iyi yolları olabilir. Buna soğuk başlatma sorunu denir, çünkü yeni bir öğeniz olduğunda, derecelendiren çok az kullanıcı vardır veya çok az öğeye oy veren yeni bir kullanıcımız olduğunda, o öğe veya o kullanıcı için işbirlikçi filtrelemenin sonuçları farklı olabilir.

İşbirlikçi bir filtreleme öneri sisteminin amacı iki vektör oluşturmaktır: Her kullanıcı için, bir kullanıcının film zevklerini somutlaştıran bir 'parametre vektörü'. Her film için, filmin bazı açıklamalarını içeren aynı boyutta bir özellik vektörü. İki vektörün iç çarpımı artı yanlılık terimi, kullanıcının o filme verebileceği derecelendirmenin bir tahminini üretmelidir.

Bir çevrimiçi alışveriş sitesine geliyorsanız ve belirli bir öğeye, belki belirli bir kitaba bakıyorsanız, web sitesi size "İşte buna benzer başka kitaplar" gibi şeyler gösterebilir veya belirli bir filme göz atıyorsanız, "İşte başka kitaplar" diyebilir. buna benzer filmler." Web siteleri bunu nasıl yapıyor?, böylece bir öğeye baktığınızda, göz önünde bulundurmanız gereken diğer benzer veya ilgili öğeleri verir. Konuştuğumuz işbirlikçi filtreleme algoritmasının size ilgili öğeleri bulmak için güzel bir yol sağladığı ortaya çıktı. Bir bakalım. Tartıştığımız işbirliğine dayalı filtrelemenin bir parçası olarak, kullanıcılara önerdikleri her öğe ı, her film ı veya diğer öğe türü için x ^ (i) özelliklerini öğrendiniz. Oysa bu haftanın başlarında, bir filmin bir aksiyon filmine karşı ne kadar romantik bir film olduğunu temsil eden özelliklerin varsayımsal bir örneğini kullanmıştım. Uygulamada, x ^ (i) özelliklerini otomatik olarak öğrenmek için bu algoritmayı kullandığınızda, x_1, x_2, x_3 özelliklerine bakarak bunları yorumlamanın oldukça zor olduğunu görürsünüz. Özellikleri öğrenmek ve söylemek oldukça zor, x_1 bir aksiyon filmi ve x_2 yabancı bir film gibi. Ama yine de, bu öğrenilmiş özellikler, topluca x_1, x_2, x_3, diğer birçok özellik ve topluca bu özelliklere sahip olmanız, o filmin nasıl olduğu hakkında bir şeyler aktarıyor. I öğesinin x ^ (i) özellikleri göz önüne alındığında, başka öğeler bulmak istiyorsanız, ı filmiyle ilgili diğer filmleri söyleyin, o zaman yapabileceğiniz şey, x ^ (k) özelliklerine sahip k öğesini bulmaya çalışmaktır. x ^ (i) 'ye benzer. Özellikle, bir özellik vektörü verildiğinde x ^ (k), x ^ (i) özelliğine benzer olarak bilinenleri belirleme şeklimiz şöyledir: toplam mı l eşittir 1 ile n n özellikleri ile x ^ (k) _l eksi x ^ (i) _l kare. Bu, x ^ (k) ile x ^ (i) arasındaki kare mesafedir ve matematikte, bu iki vektör arasındaki bu kare mesafe, x ^ (k) ve x ^ (i), bazen aşağıdaki gibi yazılır. Yalnızca x ^ (k) ile x ^ (i) arasında en küçük mesafeye sahip bir filmi değil, aynı zamanda en benzer özellik vektörlerine sahip beş veya 10 öğeyi bulursanız, x ^ (i) öğesiyle ilgili beş veya 10 öğeyi bulursunuz. Bir web sitesi oluşturuyorsanız ve kullanıcıların baktıkları belirli bir ürünle ilgili ürünleri bulmalarına yardımcı olmak istiyorsanız, bunu yapmanın iyi bir yolu olacaktır çünkü x ^ (i) özellikleri, hangi öğeyle ilgili olduğuma dair bir fikir verir. , benzer özelliklere sahip diğer öğeler x ^ (k) madde ı'e benzer olacak. Bu hafta sonunda, ilgili öğeleri bulma fikri, daha da güçlü bir önerilen sisteme ulaşmak için kullanacağımız küçük bir yapı taşı olacak. Bu bölümü tamamlamadan önce, işbirliğine dayalı filtrelemenin birkaç sınırlamasından bahsetmek istiyorum. İşbirliğine dayalı filtrelemede, bir öğe kümeniz vardır ve bu nedenle kullanıcılar ve kullanıcılar bazı öğe alt kümelerini derecelendirmiştir. Bu zayıflıklardan biri, soğuk başlangıç probleminde çok iyi olmamasıdır. Örneğin, kataloğunuzda yeni bir öğe varsa, birisinin yeni bir film yayınladığını ve henüz hiç kimsenin o filmi derecelendirmediğini söyleyin, daha önce çok az kullanıcı derecelendirmişse yeni öğeyi nasıl sıralarsınız? Benzer şekilde, yalnızca birkaç öğeyi derecelendiren yeni kullanıcılar için, onlara makul bir şey gösterdiğimizden nasıl emin olabiliriz? Daha önceki bir videoda normalleşmenin bu konuda nasıl yardımcı olabileceğini görebiliyorduk ve bu çok yardımcı oluyor. Ancak, kullanıcılara çok az öğeyi derecelendiren, ilgilerini çekmesi muhtemel şeyleri göstermenin belki de daha iyi yolları. Buna soğuk başlatma sorunu denir, çünkü yeni bir öğeniz olduğunda, derecelendiren çok az kullanıcı vardır veya çok az öğe derecelendiren yeni bir kullanıcımız vardır, o öğe veya o kullanıcı için ortak filtreleme sonuçları çok doğru olmayabilir. İşbirliğine dayalı filtrelemenin ikinci sınırlaması, size yan bilgileri veya öğeler veya kullanıcılar hakkında ek bilgileri kullanmanın doğal bir yolunu vermemesidir. Örneğin, kataloğunuzdaki belirli bir film için, filmin türünün ne olduğunu, kimin film yıldızı olduğunu, stüdyo olup olmadığını, bütçenin ne olduğunu vb. Biliyor olabilirsiniz. Belirli bir film hakkında birçok özelliğe sahip olabilirsiniz. Tek bir kullanıcı için demografileri hakkında yaşları, cinsiyetleri, konumları gibi bir şeyler biliyor olabilirsiniz. Belirli film türlerini sevdiklerini, ancak diğer film türlerini sevmediklerini söylemeleri gibi tercihleri ifade ederler veya kullanıcının IP adresini biliyorsanız, bu size bir kullanıcının konumu hakkında çok şey söyleyebilir ve kullanıcının konumunu bilmek de ne olabileceğini tahmin etmenize yardımcı olabilir. kullanıcının sitenize bir cep telefonundan mı yoksa masaüstünden mi eriştiğini veya hangi web tarayıcısını kullandıklarını biliyorsanız, kullanıcının ilgisini çekin. Bunların hepsinin alabileceğiniz küçük ipuçları olduğu ortaya çıktı. Bir kullanıcının tercihleri ile şaşırtıcı bir şekilde ilişkilendirilebilirler. Bu arada, Chrome'u Firefox'a karşı Safari'ye karşı Microsoft Edge tarayıcısına karşı kullanan kullanıcıların aslında çok farklı şekillerde davrandıkları biliniyor. Kullanıcının web tarayıcısını bilmek bile, bu kullanıcının neyi sevebileceğine dair yeterli veri topladığınızda size bir ipucu verebilir. İşbirliğine dayalı filtreleme, size birden fazla öğenin derecelendirmesini veren birden fazla kullanıcımız olmasına rağmen, çok güçlü bir algoritma kümesidir, ayrıca bazı sınırlamaları da vardır. Bir sonraki videoda, bu sınırlamaların çoğunu ele alabilecek içerik tabanlı filtreleme algoritmaları geliştirmeye devam edelim. İçerik tabanlı filtreleme algoritmaları, günümüzde birçok ticari uygulamada kullanılan sabit bir sanat tekniğidir. Gidip nasıl çalıştıklarına bir bakalım.

## Collaborative filtering vs Content-based filtering
İşbirlikçi filtrelemede genel yaklaşım, sizinle benzer puanlar veren kullanıcıların puanlarına göre size öğeler önermemizdir. Bazı öğeler için bazı derecelendirmeler veren bazı kullanıcılarımız var ve algoritma, size yeni öğeler önermek için bunu nasıl kullanacağını buluyor. Bunun tersine, içerik tabanlı filtreleme, size ne önerileceğine karar vermede farklı bir yaklaşım benimser. İçerik tabanlı bir filtreleme algoritması, iyi bir eşleşme bulmak için kullanıcıların özelliklerine ve öğelerin özelliklerine göre size öğeler önerecektir. Başka bir deyişle, her bir öğenin bazı özelliklerinin yanı sıra her kullanıcının bazı özelliklerine sahip olmayı gerektirir ve bu özellikleri, hangi öğelerin ve kullanıcıların birbirleri için iyi bir eşleşme olabileceğine karar vermeye çalışmak için kullanır.

Bu videoda, içerik tabanlı filtreleme algoritması adı verilen ikinci tür bir tavsiye sistemi geliştirmeye başlayacağız. Başlamak için, şu ana kadar bakacağımız işbirliğine dayalı filtreleme yaklaşımını bu yeni içerik tabanlı filtreleme yaklaşımıyla karşılaştıralım ve karşılaştıralım. Bir bakalım. İşbirliğine dayalı filtrelemede genel yaklaşım, sizinle benzer derecelendirmeler veren kullanıcıların derecelendirmelerine göre size öğeler önermemizdir. Bazı öğeler için bazı derecelendirmeler veren birkaç kullanıcımız var ve algoritma size yeni öğeler önermek için bunun nasıl kullanılacağını buluyor. Buna karşılık, içerik tabanlı filtreleme, size ne önereceğinize karar vermek için farklı bir yaklaşım benimser. İçerik tabanlı bir filtreleme algoritması, iyi bir eşleşme bulmak için kullanıcıların özelliklerine ve öğelerin özelliklerine göre size öğeler önerecektir. Başka bir deyişle, her bir kullanıcının bazı özelliklerinin yanı sıra her bir öğenin bazı özelliklerine sahip olmayı gerektirir ve bu özellikleri, hangi öğelerin ve kullanıcıların birbirleriyle iyi bir eşleşme olabileceğine karar vermek için kullanır. İçerik tabanlı bir filtreleme algoritmasıyla, kullanıcıların bazı öğeleri derecelendirdiği verilere hala sahipsiniz. İçerik tabanlı filtreleme, j kullanıcısının i öğesini derecelendirip derecelendirmediğini belirtmek için r, i, j'yi kullanmaya devam edecek ve tanımlanmışsa j kullanıcısına i öğesi verilen derecelendirmeyi belirtmek için y i, j'yi kullanmaya devam edecektir. Ancak içerik tabanlı filtrelemenin anahtarı, potansiyel olarak saf bir işbirliğine dayalı filtreleme yaklaşımının yapabileceğinden daha iyi eşleşmeler bulmak için kullanıcının ve öğelerin özelliklerini iyi kullanabileceğimizdir. Bunun nasıl çalıştığına bir göz atalım. Film önerileri söz konusu olduğunda, işte bazı özellik örnekleri. Kullanıcının yaşını biliyor olabilirsiniz veya kullanıcının cinsiyetini biliyor olabilirsiniz. Bu, karar ağaçlarından bahsederken gördüğünüze benzer, kullanıcının kendi belirlediği cinsiyetinin erkek mi kadın mı yoksa bilinmeyen mi olduğuna bağlı değerlere sahip tek sıcak bir özelliğe sahip olabileceğiniz tek sıcak bir özellik olabilir. ve kullanıcının ülkesini biliyor olabilirsiniz. Dünyada yaklaşık 200 ülke varsa, yaklaşık 200 olası değere sahip tek seferlik bir özellik de olun. Bu özellik vektörünü oluşturmak için kullanıcının geçmiş davranışlarına da bakabilirsiniz. Örneğin, kataloğunuzdaki en iyi bin filme bakarsanız, bunlardan hangisinin kullanıcının izlediği dünyanın en popüler bin filmini anlatan bin özellik oluşturabilirsiniz. Aslında, yeni özellikler oluşturmak için kullanıcının vermiş olabileceği derecelendirmeleri de alabilirsiniz. Bir dizi filminiz varsa ve her filmin hangi türde olduğunu biliyorsanız, kullanıcının verdiği tür başına ortalama derecelendirmenin olduğu ortaya çıkıyor. Kullanıcının derecelendirdiği tüm romantik filmler arasında ortalama derecelendirme neydi? Kullanıcının derecelendirdiği tüm aksiyon filmleri arasında ortalama derecelendirme neydi? Ve böylece diğer tüm türler için. Bu da kullanıcıyı tanımlamak için güçlü bir özellik olabilir. Bu özellik ile ilgili ilginç bir şey, aslında kullanıcının verdiği derecelendirmelere bağlı olmasıdır. Ama bunda yanlış bir şey yok. Kullanıcının derecelendirmelerine bağlı bir özellik vektörü oluşturmak, o kullanıcıyı tanımlamak için bir özellik vektörü geliştirmenin tamamen iyi bir yoludur. Bu gibi özelliklerle, daha sonra bir özellik vektörü x alt simgesi u ile gelebilir, kullanıcı üst simgesi olarak kullanabilirsiniz j kullanıcı için j. Benzer şekilde, her öğenin her filmi için filmin yılı neydi gibi bir dizi özellik de bulabilirsiniz. Bilinen filmin türü veya türleri nedir? Filmin eleştirmen yorumları varsa, eleştirmenlerin film hakkında söyledikleriyle ilgili bir şeyler yakalamak için bir veya birden fazla özellik oluşturabilirsiniz. Ya da bir kez daha, bu filmin ortalama derecelendirmesinin bir özelliğini oluşturmak için filmin kullanıcı derecelendirmelerini gerçekten alabilirsiniz. Bu özellik yine kullanıcılara verilen derecelendirmelere bağlıdır, ancak yine bunda yanlış bir şey yapmaz. Belirli bir film için, filmin aldığı derecelendirmelere bağlı olarak, filmin ortalama derecelendirmesi gibi bir özellik oluşturabilirsiniz. İsterseniz, filmlerin diğer özelliklerini de oluşturmak istedikleri için ülke başına ortalama derecelendirmeye veya kullanıcı demografisi başına ortalama derecelendirmeye sahip olabilirsiniz. Bununla, her film için, daha sonra bir özellik vektörü oluşturabilirsiniz, bunu x alt simgesi m, m film anlamına gelir ve üst simge ben film için ben. Bunun gibi özellikler göz önüne alındığında, görev, belirli bir filmin iyi olup olmayacağını anlamaya çalışmaktır kullanıcı j için eşleşme. Kullanıcı özelliklerinin ve film özelliklerinin boyut olarak çok farklı olabileceğine dikkat edin. Örneğin, kullanıcı özellikleri 1500 sayı olabilir ve film özellikleri yalnızca 50 sayı olabilir. Bu da sorun değil. İçerik tabanlı filtrelemede, kullanıcıları ve filmleri eşleştirmeyi öğrenen bir algoritma geliştireceğiz. Daha önce, film ı'deki j kullanıcısının derecelendirmesini xi plus bj'nin wj dot ürünleri olarak tahmin ediyorduk. İçerik tabanlı filtreleme geliştirmek için bj'den kurtulacağım. Bunun, içerik tabanlı filtrelemenin performansına hiç zarar vermeyeceği ortaya çıktı. Bir film için j ve xi kullanıcısı için wj yazmak yerine, bunun yerine bu gösterimi vj_u ile değiştireceğim. Bu v burada bir vektör anlamına gelir. J kullanıcısı için hesaplanan sayıların bir listesi olacak ve buradaki u alt simgesi kullanıcı anlamına geliyor. Xi yerine, filmi temsil etmek için ayrı bir vektör alt simgesi m hesaplayacağım ve film için bir üst simge ne anlama geliyor. Vektör olarak Vj_u kullanıcı j ve vı_m özelliklerinden hesaplanan sayıların listesi, önceki film slaytında gördüğünüz gibi özelliklerden hesaplanan sayıların listesidir. ben. Bu vektörlerin uygun bir seçimini bulabilirsek, vj_u ve vi_m, o zaman umarım bu iki vektör arasındaki nokta çarpımı, kullanıcı j'nin film i'ye verdiği derecelendirmenin iyi bir tahmini olacaktır. Sadece bir öğrenme algoritmasının ne ile gelebileceğini gösterin. Eğer v, u, yani bir kullanıcı vektörü, kullanıcının tercihlerini yakaladığı ortaya çıkarsa, diyelim ki 4.9, 0.1 vb. Bunun gibi numaraların listesi. İlk sayı, romantik filmleri ne kadar sevdiklerini yakalar. Sonra ikinci sayı, aksiyon filmlerini ne kadar sevdiklerini vb. Yakalar. Sonra v_m, film vektörü 4.5, 0.2, vb. Bu sayıların ne kadar romantik bir film olduğunu, bunun ne kadar aksiyon filmi olduğunu vb. Yakalar. Daha sonra, bu sayı listelerini eleman bazında çarpıp bir miktar alan nokta ürünü, umarım, bu kullanıcının bu filmi ne kadar seveceğine dair bir fikir verecektir. Bir kullanıcının özellikleri verilen zorluklar, örneğin xj_u, kullanıcının tercihlerini kısaca veya kompakt bir şekilde temsil eden bu vj_u vektörünü nasıl hesaplayabiliriz? Benzer şekilde bir filmin özellikleri göz önüne alındığında, vi_m'yi nasıl hesaplayabiliriz? X_u ve x_m boyut olarak farklı olabilirken, biri çok uzun sayı listeleri olabilir, biri çok daha kısa liste olabilir, v burada aynı boyutta olmalıdır. Çünkü v_u ve v_m arasında bir nokta çarpımı almak istiyorsanız, her ikisinin de aynı boyutlara sahip olması gerekir, örneğin bunların her ikisi de 32 sayıdır. Özetlemek gerekirse, işbirliğine dayalı filtrelemede, farklı öğelerin derecelendirmelerini veren kullanıcı sayımız vardı. Buna karşılık, içerik tabanlı filtrelemede, kullanıcıların özelliklerine ve öğelerin özelliklerine sahibiz ve kullanıcılar ile öğeler arasında iyi eşleşmeler bulmanın bir yolunu bulmak istiyoruz. Bunu yapmanın yolu, bu vektörleri, kullanıcılar için v_u ve filmler üzerindeki öğeler için v_m'yi hesaplamak ve ardından iyi eşleşmeler bulmaya çalışmak için aralarında nokta ürünleri almaktır. V_u ve v_m'yi nasıl hesaplarız? Bir sonraki videoda buna bir göz atalım.

## Deep learning for content-based filtering
İçerik tabanlı bir filtreleme algoritması oluşturmak için derin öğrenmeyi bu şekilde kullanabilirsiniz. Karar ağaçlarından ve sinir ağlarına karşı karar ağaçlarının artıları ve eksilerinden bahsettiğimizi hatırlarsınız. Sinir ağlarının faydalarından birinin, daha büyük bir sistem oluşturmak için birden fazla sinir ağını konsolda çalıştıracak şekilde bir araya getirmenin daha kolay olduğundan bahsetmiştim. Az önce gördüğünüz şey aslında bunun bir örneğiydi, bir kullanıcı ağı ile film ağını alıp bir araya getirebilir ve ardından çıktıların iç çarpımını alabilirdik. İki sinir ağını bir araya getirme yeteneği, oldukça güçlü olduğu ortaya çıkan daha karmaşık bir mimariyi bu şekilde bulmayı başardık. Bu algoritmaları pratikte uyguluyorsanız, geliştiricilerin genellikle bu içerik tabanlı filtreleme algoritmalarını beslemek için gereken özellikleri dikkatli bir şekilde tasarlamak için çok fazla zaman harcadıklarını görüyorum. Sonunda bu sistemlerden birini ticari olarak kurarsak, bu uygulama için de iyi özellikler tasarlamak için biraz zaman ayırmaya değer olabilir. Bu uygulamalar açısından, algoritmanın açıkladığımız gibi bir sınırlaması, önermek isteyebileceğiniz birçok farklı filmden oluşan geniş bir kataloğunuz varsa çalıştırmanın hesaplama açısından çok pahalı olabilmesidir. Bir sonraki videoda, bazı pratik konulara ve çok büyük ürün kataloglarında bile çalışan bir ölçek oluşturmak için bu algoritmayı nasıl değiştirebileceğinize bir göz atalım. 

İçerik tabanlı bir filtreleme algoritması geliştirmenin iyi bir yolu, derin öğrenmeyi kullanmaktır. Bu videoda gördüğünüz yaklaşım, günümüzde birçok önemli ticari son teknoloji içerik tabanlı filtreleme algoritmasının oluşturulma şeklidir. Bir bakalım. Yaklaşımımızda, yaş, cinsiyet, ülke vb. Gibi bir kullanıcıyı tanımlayan bir özellik vektörü verildiğinde, v_u vektörünü hesaplamamız gerektiğini ve benzer şekilde, yayın yılı, filmdeki yıldızlar vb. Gibi bir filmi tanımlayan bir vektör verildiğinde, v_m vektörünü hesaplamamız gerekiyor. İlkini yapmak için bir sinir ağı kullanacağız. İlk sinir ağı, kullanıcı ağı olarak adlandıracağımız ağ olacaktır. İşte kullanıcının özelliklerinin listesini girdi olarak alan bir kullanıcı ağı örneği, x_u, yani yaş, cinsiyet, kullanıcının ülkesi vb. Daha sonra birkaç katman kullanarak, yoğun sinir ağı katmanları diyelim, kullanıcıyı tanımlayan bu v_u vektörünü çıkarır. Bu sinir ağında çıktı katmanının 32 birimi olduğuna ve dolayısıyla v_u'nun aslında 32 sayıdan oluşan bir liste olduğuna dikkat edin. Daha önce kullandığımız sinir ağlarının çoğunun aksine, son katman tek bir birime sahip bir katman değil, 32 birime sahip bir katmandır. Benzer şekilde, bir film için v_m'yi hesaplamak için, filmin girdi özelliklerini alan ve bir sinir ağının birkaç katmanı aracılığıyla filmi tanımlayan vektör olan v_m'yi çıkaran aşağıdaki gibi bir film ağımız olabilir. Son olarak, bu kullanıcının o filmdeki derecelendirmesini v_m ile v_ u nokta ürünü olarak tahmin edeceğiz. Kullanıcı ağının ve film ağının varsayımsal olarak farklı sayıda gizli katmana ve gizli katman başına farklı sayıda birime sahip olabileceğine dikkat edin. Tüm çıktı katmanının aynı boyutta aynı boyutta olması gerekir. Şimdiye kadar gördüğünüz açıklamada, 1-5 veya 0-5 yıldızlı film derecelendirmesini tahmin ediyorduk. İkili etiketlerimiz olsaydı, y kullanıcıya bir öğeyi beğenirse veya tercih ederse, bu algoritmayı çıktı olarak da değiştirebilirsiniz. V_u.v_m yerine, sigmoid işlevini buna uygulayabilir ve bunu y ^ i, j'nin 1 olma olasılığını tahmin etmek için kullanabilirsiniz. Bu gösterimi özetlemek için, bunun j kullanıcısının film i'deki tahmini olduğunu vurgulamak istiyorsak, buraya ı ve j üst simgelerini de ekleyebiliriz. Buraya kullanıcı ağını ve film ağını iki ayrı sinir ağı olarak çizdim. Ama onları tek bir sinir ağıymış gibi tek bir diyagramda bir araya getirebileceğimiz ortaya çıktı. İşte böyle görünüyor. Bu diyagramın üst kısmında, x_u'yu giren ve v_u'yu hesaplayan kullanıcı ağımız var. Bu diyagramın alt kısmında, film ağının ne olduğuna sahibiz, girdi x_m'dir ve sonunda v_m'yi hesaplar ve bu iki vektör daha sonra birlikte nokta çarpımıdır. Buradaki nokta nokta çarpımını temsil ediyor ve bu bize tahminimizi veriyor. Şimdi, bu modelin birçok parametresi var. Bir sinir ağının bu katmanlarının her biri, sinir ağının olağan bir dizi parametresine sahiptir. Hem kullanıcı ağının hem de film ağının tüm parametrelerini nasıl eğitirsiniz? Yapacağımız şey, ortak filtrelemede gördüğünüz maliyet işlevine çok benzer olacak bir maliyet işlevi J oluşturmaktır; bu, bazı filmleri derecelendiren bazı kullanıcıların bazı verilerine sahip olduğunuzu varsayarsak, tüm ı ve j çiftlerini toplayacağız. etiketlerin olduğu yerde, burada i, j, tahmin arasındaki farkın 1'ine eşittir. Bu, v_m ^ i eksi y ^ ij karesi olan v_u ^ j nokta ürünü olacaktır. Bu modeli eğitme şeklimiz, sinir ağının parametrelerine bağlı olarak, burada kullanıcılar ve filmler için farklı vektörler elde edersiniz. Yapmak istediğimiz şey, sinir ağının parametrelerini eğitmektir, böylece kullanıcılar ve filmler için vektörlerle sonuçlanırsınız, bu da burada elde ettiğiniz tahminlere küçük kare hatayla sonuçlanır. Açık olmak gerekirse, kullanıcı ve film ağları için ayrı bir eğitim prosedürü yoktur. Buradaki ifade, kullanıcının ve film ağlarının tüm parametrelerini eğitmek için kullanılan maliyet fonksiyonudur. İki ağı, v_u ve v_m'nin y ^ ij'yi ne kadar iyi tahmin ettiğine göre yargılayacağız ve bu maliyet işleviyle, sinir ağının parametrelerini ayarlamak için gradyan inişini veya başka bir optimizasyon algoritmasını kullanacağız. J maliyet işlevinin mümkün olduğunca küçük olmasına neden olur. Bu modeli düzenlemek istiyorsanız, sinir ağlarını parametrelerinin değerlerini küçük tutmaya teşvik etmek için olağan sinir ağı düzenleme terimini de ekleyebiliriz. Görünüşe göre, bu modeli eğittikten sonra, benzer öğeleri bulmak için bunu da kullanabilirsiniz. Bu, işbirliğine dayalı filtreleme özellikleriyle gördüklerimize benzer ve benzer öğeleri bulmanıza da yardımcı olur. Bir bakalım. V_u ^ j, x_ u ^ j özelliklerine sahip bir j kullanıcısını tanımlayan 32 uzunluğundaki bir vektördür. Benzer şekilde, v ^ i_m, burada bu özelliklere sahip bir filmi tanımlayan 32 uzunluğundaki bir vektördür. Belirli bir film verildiğinde, ona benzer başka filmler bulmak istiyorsanız ne olur? Bu vektör v ^ i_m, i filmini tanımlar. Buna benzer başka filmler bulmak istiyorsanız, o zaman diğer filmleri arayabilirsiniz. k böylece filmi tanımlayan vektör arasındaki mesafe k ve filmi tanımlayan vektör ben, kare mesafenin küçük olması. Bu ifade, daha önce sahip olduğumuza benzer bir rol oynar. ortak filtrelemeözelliklerine benzer x ^ k özelliklerine sahip bir film bulmaktan bahsettiğimiz yer x ^ i. Böylece, bu yaklaşımla, belirli bir öğeye benzer öğeleri de bulabilirsiniz. Son bir not, bu önceden önceden hesaplanabilir. Bununla demek istediğim, tüm filmlerinizin listesini incelemek için bir gecede bir hesaplama sunucusu çalıştırabilir ve her film için ona benzer filmler bulabilirsiniz, böylece yarın, bir kullanıcı web sitesine gelirse ve belirli bir filme göz atıyorsa, önceden 10'a kadar hesaplamış olabilirsiniz veya o sırada kullanıcıya gösterilecek en benzer 20 film. Belirli bir filme benzer olanı önceden hesaplayabilmeniz, daha sonra bu yaklaşımı çok geniş bir film kataloğuna ölçeklendirme hakkında konuştuğumuzda önemli olacaktır. İçerik tabanlı bir filtreleme algoritması oluşturmak için derin öğrenmeyi bu şekilde kullanabilirsiniz. Karar ağaçları ve karar ağaçlarının sinir ağlarına karşı artıları ve eksileri hakkında konuştuğumuzu hatırlayabilirsiniz. Sinir ağlarının faydalarından birinin, birden fazla sinir ağını almanın ve daha büyük bir sistem oluşturmak için konsolda çalışmalarını sağlamak için bunları bir araya getirmenin daha kolay olduğunu belirttim. Az önce gördüğünüz şey aslında bunun bir örneğiydi, burada bir kullanıcı ağını ve film ağını alıp bunları bir araya getirip çıktıların iç çarpımını alabilirdik. Bu iki sinir ağını bir araya getirme yeteneği, bu şekilde oldukça güçlü olduğu ortaya çıkan daha karmaşık bir mimari bulmayı başardık. Bir not, bu algoritmaları pratikte uyguluyorsanız, geliştiricilerin genellikle bu içerik tabanlı filtreleme algoritmalarına beslemek için gereken özellikleri dikkatlice tasarlamak için çok zaman harcadıklarını görüyorum. Bu sistemlerden birini ticari olarak inşa edersek, bu uygulama için de iyi özellikler tasarlamak için biraz zaman harcamaya değer olabilir. Bu uygulamalar açısından, algoritmanın tanımladığımız gibi bir sınırlaması, tavsiye etmek isteyebileceğiniz birçok farklı filmden oluşan geniş bir kataloğunuz varsa, çalıştırmanın hesaplamalı olarak çok pahalı olabileceğidir. Bir sonraki videoda, bazı pratik konulara ve çok büyük ürün katalogları üzerinde bile çalışan bir ölçek oluşturmak için bu algoritmayı nasıl değiştirebileceğinize bir göz atalım. Bunu bir sonraki videoda görelim.

## Recommending from a large catalogue
Günümüzün tavsiye edilen sistemlerinin bazen önermek için bir avuç öğe seçmesi gerekebilir. Binlerce veya milyonlarca veya 10 milyonlarca veya daha fazla öğeden oluşan bir katalogdan. Bunu hesaplamalı olarak verimli bir şekilde nasıl yaparsınız, bir göz atalım. İşte ağınızda, bir kullanıcının bir öğeyi nasıl derecelendirebileceği hakkında tahminlerde bulunmak için kullanıyoruz. Bugün büyük bir film akış sitesinde binlerce film veya hangi reklamın gösterileceğine karar vermeye çalışan bir sistem olabilir. Aralarından seçim yapabileceğiniz milyonlarca reklamdan oluşan bir kataloğa sahip olabilir. Veya bir müzik akışı sitesinde, aralarından seçim yapabileceğiniz 10 milyonlarca şarkı olabilir. Ve büyük çevrimiçi alışveriş sitelerinde, aralarından seçim yapabileceğiniz milyonlarca hatta 10 milyonlarca ürün olabilir. Bir kullanıcı web sitenizde göründüğünde, bazı Xu özelliklerine sahiptir. Ancak, üründe hesaplama yapmak için bu sinir ağı aracılığıyla beslenmek için binlerce milyonlarca öğe almanız gerekiyorsa. Hangi ürünleri önermeniz gerektiğini bulmak için sinir ağı çıkarımı yapmak zorunda. Bir kullanıcı web sitenizde her göründüğünde binlerce milyonlarca kez hesaplamalı ve uygulanamaz hale gelir. Birçok hukuk ölçeğinde önerilen sistem, geri alma ve sıralama adımları olarak adlandırılan iki adım olarak uygulanmaktadır. Buradaki fikir, alma adımı sırasında, makul öğe adaylarının geniş bir listesini oluşturacaktır. Bu, kullanıcıya önerebileceğiniz pek çok olası şeyi kapsamaya çalışır ve alma adımı sırasında sorun olmaz. Kullanıcının muhtemelen beğenmeyeceği pek çok öğe eklerseniz ve ardından sıralama adımı sırasında kullanıcıya önerilecek en iyi öğeleri ince ayar yapacak ve seçecektir. İşte bir örnek, alma adımı sırasında şöyle bir şey yapabiliriz. Kullanıcının izlediği son 10 filmin her biri için en benzer 10 filmi bulun. Yani bu, örneğin bir kullanıcı vektör VIM ile I filmini izlemişse buna benzer vektör VKM ile hey filmleri bulabilirsiniz anlamına gelir. Ve benzer filmleri bulmadaki son videoda gördüğünüz gibi, verilen film önceden hesaplanabilir. Bir film vermek için en benzer filmleri önceden hesapladıktan sonra, bir arama tablosunu kullanarak sonuçları alabilirsiniz. 
Bu size, web sitenizde henüz ortaya çıkan, kullanıcıya önermek için belki biraz makul filmlerden oluşan bir başlangıç seti verecektir. Ek olarak, kullanıcının en çok görüntülenen üç türü için eklemeye karar verebilirsiniz. Kullanıcının çok sayıda aşk filmi, çok sayıda komedi filmi ve çok sayıda tarihi drama izlediğini varsayalım. Ardından, bu üç türün her birindeki en iyi 10 filmi olası öğe adayları listesine eklerdik. Ve sonra belki de bu listeye kullanıcının ülkesindeki en iyi 20 filmi de ekleyeceğiz. Dolayısıyla, bu geri alma adımı çok hızlı bir şekilde yapılabilir ve sonunda 100 veya belki de 100'lerce makul filmden oluşan bir liste elde edebilirsiniz. Kullanıcıya tavsiye etmek ve umarım bu liste bazı iyi seçenekler önerecektir. Ancak kullanıcının hiç hoşlanmayacağı bazı seçenekler içeriyorsa da sorun değil. Geri alma adımının amacı, yeterli sayıda filmin en azından içinde çok sayıda iyi filmin olması için geniş kapsama alanı sağlamaktır. Son olarak, alma adımı sırasında aldığımız tüm öğeleri alır ve bunları bir liste halinde birleştiririz. İki pişiriciyi kaldırmak ve kullanıcının daha önce yıkadığı veya daha önce satın aldığı ve ona tekrar önermek istemeyebileceğiniz öğeleri kaldırmak. Bunun ikinci adımı, sıralama adımıdır. Sıralama adımı sırasında, geri alma adımı sırasında alınan listeyi alacaksınız. Yani bu sadece yüzlerce olası film olabilir ve bunları öğrenilen modeli kullanarak sıralayabilir. Bunun anlamı, kullanıcı özellik vektörünü ve film aktörünü bu sinir ağına besleyeceğinizdir. Ve kullanıcı film çiftlerinin her biri için tahmin edilen derecelendirmeyi hesaplayın. Ve buna dayanarak, artık se 100'den fazla filme sahipsiniz, kullanıcının yüksek puan vermesi en muhtemel olan filmler. Ve sonra, kullanıcının ne vereceğini düşündüğünüze bağlı olarak, kullanıcıya öğelerin sıralama listesini görüntüleyebilirsiniz. Ek bir optimizasyon için en yüksek puan, hesaplanmış VM'niz varsadır. Önceden tüm filmler için, VU'yu hesaplamak için tek yapmanız gereken sinir ağının bu bölümünde tek seferde çıkarım yapmaktır. Ardından, web sitenizdeki kullanıcı için az önce hesapladıkları VU'yu hemen şimdi alın. Ve VU ile VM arasındaki iç çarpımı alın. Alma adımı sırasında aldığınız filmler için. Yani bu hesaplama nispeten hızlı bir şekilde yapılabilir. Alma adımı sadece 100'lerce filmi getiriyorsa, bu albüm için vermeniz gereken kararlardan biri, alma adımı sırasında kaç tane öğe almak istediğinizdir? Daha doğru sıralama adımını beslemek için. Alma adımı sırasında, daha fazla öğenin alınması daha iyi performansla sonuçlanma eğiliminde olacaktır. Ancak algoritma, 100 veya 500 veya 1000 öğeyi almak için kaç öğenin alınacağı arasındaki değiş tokuşu analiz etmek veya optimize etmek için daha yavaş olacaktır. Ek öğelerin ne kadar geri alındığını görmek için çevrimdışı deneyler yapmanızı tavsiye ederim. Ne kadar ek öğe almanın daha alakalı önerilerle sonuçlandığını görmek için çevrimdışı deneyler yapmanızı öneririm. Ve özellikle, tahmin edilen olasılık ise YIJ. Sinir ağı modelinize göre bire eşittir. Ya da modelinizin tahminine göre alınan öğelerin Y'nin tahmini derecesinin yüksek olması, çok daha yüksek çıkıyorsa. Sadece 100 öğe yerine 500 öğe alacak olsaydınız, bu belki daha fazla öğe almak anlamına gelirdi. Albümü biraz yavaşlatsa da. Ancak ayrı alma adımı ve sıralama adımı ile bu, günümüzde önerilen birçok sistemin hem hızlı hem de doğru sonuçlar vermesini sağlar. Çünkü alma adımı, üzerinde daha ayrıntılı etki ve iç ürün yapmaya değmeyecek birçok öğeyi budamaya çalışır. Ve sonra, sıralama adımı, kullanıcının gerçekten zevk alması muhtemel öğelerin neler olduğu konusunda daha dikkatli bir tahmin yapar, bu yüzden bu kadar. Önerilen sisteminizin çok büyük film veya ürün kataloglarında bile verimli çalışmasını bu şekilde sağlarsınız. Şimdi, önerilen sistemlerimiz kadar ticari açıdan da önemli olduğu, bunlarla ilgili bazı önemli etik sorunların da olduğu ortaya çıktı. Ve ne yazık ki zarar yaratan tavsiye edilen sistemler olmuştur. Kendi önerilen sisteminizi oluştururken, umarım etik bir yaklaşım benimser ve kullanıcılarınıza hizmet etmek için kullanırsınız. Ve sizin ve çalıştığınız şirket kadar büyük bir toplum. Bir sonraki videoda önerilen sistemlerle ilgili etik sorunlara bir göz atalım

Günümüzün önerilen sistemlerinin bazen tavsiye etmek için bir avuç öğe seçmesi gerekecektir. Binlerce veya milyonlarca veya 10'lu milyonlarca veya daha fazla öğeden oluşan bir katalogdan. Bunu hesaplamalı olarak nasıl verimli bir şekilde yaparsınız, bir göz atalım. İşte ağınızda, bir kullanıcının bir öğeyi nasıl değerlendirebileceğine dair tahminlerde bulunmak için kullanıyoruz. Bugün büyük bir film akışı sitesinde binlerce film veya hangi reklamın gösterileceğine karar vermeye çalışan bir sistem olabilir. Aralarından seçim yapabileceğiniz milyonlarca reklamdan oluşan bir kataloğa sahip olabilir. Veya bir müzik akışı sitesinde aralarından seçim yapabileceğiniz 10 milyon şarkı olabilir. Ve büyük çevrimiçi alışveriş siteleri, aralarından seçim yapabileceğiniz milyonlarca hatta 10'lu milyonlarca ürüne sahip olabilir. Bir kullanıcı web sitenizde göründüğünde, bazı Xu özelliklerine sahiptir. Ancak, ürünü hesaplamak için bu sinir ağından beslenmek için binlerce milyonlarca öğe almanız gerekiyorsa. Hangi ürünleri önermeniz gerektiğini bulmak için sinir ağı çıkarımını çalıştırmanız gerekir. Bir kullanıcı web sitenizde her göründüğünde binlerce milyon kez hesaplama yapılamaz hale gelir. Hukuk ölçeğinde önerilen birçok sistem, geri alma ve sıralama adımları olarak adlandırılan iki adım olarak uygulanmaktadır. Fikir, geri alma adımı sırasında makul öğe adaylarının geniş bir listesini oluşturacaktır. Bu, kullanıcıya önerebileceğiniz birçok olası şeyi kapsamaya çalışır ve geri alma adımı sırasında sorun olmaz. Kullanıcının beğenmeyeceği birçok öğe eklerseniz ve sıralama adımı sırasında kullanıcıya önerilecek en iyi öğeleri ince ayar yapar ve seçersiniz. İşte bir örnek, geri alma adımı sırasında şöyle bir şey yapabiliriz. Kullanıcının izlediği son 10 filmin her biri için en benzer 10 filmi bulun. Yani bu, örneğin bir kullanıcı vector VİM ile İ filmini izlediyse, buna benzer vector VKM ile hey filmlerini bulabileceğiniz anlamına gelir. Ve benzer filmleri bulan son videoda gördüğünüz gibi, verilen film önceden hesaplanabilir. Bu nedenle, bir film vermek için en benzer filmleri önceden hesapladıktan sonra, sonuçları bir arama tablosu kullanarak yukarı çekebilirsiniz. Bu, web sitenizde yeni ortaya çıkan kullanıcıya önermeniz için size belki biraz makul bir film seti verecektir. Ek olarak, kullanıcının en çok görüntülenen üç türü ne olursa olsun eklemeye karar verebilirsiniz. Kullanıcının çok sayıda romantik film, çok sayıda komedi filmi ve çok sayıda tarihi drama izlediğini söyleyin. Ardından, bu üç türün her birindeki en iyi 10 filmi olası madde adayları listesine ekleyeceğiz. Ve sonra belki de bu listeye kullanıcının ülkesindeki en iyi 20 filmi de ekleyeceğiz. Yani bu geri alma adımı çok hızlı bir şekilde yapılabilir ve sonunda 100 veya belki 100'lerce makul filmden oluşan bir liste elde edebilirsiniz. Kullanıcıya tavsiye etmek ve umarım bu liste bazı iyi seçenekler önerecektir. Ancak, kullanıcının hiç beğenmeyeceği bazı seçenekler içeriyorsa da sorun değil. Geri alma adımının amacı, en azından içinde çok sayıda iyi filmin olması için geniş kapsama alanı sağlamaktır. Son olarak, geri alma adımı sırasında aldığımız tüm öğeleri alır ve bunları bir listede birleştirirdik. İki ocağın çıkarılması ve kullanıcının daha önce yıkadığı veya kullanıcının daha önce satın aldığı ve onlara tekrar tavsiye etmek istemeyebileceğiniz öğelerin çıkarılması. Bunun ikinci adımı daha sonra sıralama adımıdır. Sıralama adımı sırasında, alma adımı sırasında alınan listeyi alırsınız. Yani bu sadece yüzlerce olası film olabilir ve öğrenilen modeli kullanarak sıralayabilir. Bunun anlamı, kullanıcı özelliği vektörünü ve film özelliği aktörünü bu sinir ağına besleyeceksiniz. Ve kullanıcı film çiftlerinin her biri için öngörülen derecelendirmeyi hesaplar. Ve buna dayanarak, artık kullanıcının yüksek puan vermesi en muhtemel olan se 100 plus filmlerinin hepsine sahipsiniz. Ve sonra, kullanıcının ne vereceğini düşündüğünüze bağlı olarak kullanıcıya öğelerin sıra listesini görüntüleyebilirsiniz. Bir ek optimizasyonun en yüksek derecesi, vm'yi hesapladıysanız. Önceden tüm filmler için yapmanız gereken tek şey, vu'yu hesaplamak için sinir ağının bu bölümünde bir kez çıkarım yapmaktır. Ve sonra şu anda web sitenizdeki kullanıcı için hesapladıkları vu'yu alın. Ve VU ve VM arasındaki iç ürünü alın. Alma adımı sırasında aldığınız filmler için. Dolayısıyla bu hesaplama nispeten hızlı bir şekilde yapılabilir. Geri alma adımı sadece 100'lerce film getiriyorsa, bu albüm için almanız gereken kararlardan biri, geri alma adımı sırasında kaç öğe almak istediğinizdir? Daha doğru sıralama adımına geçmek için. Alma adımı sırasında, daha fazla öğe almak daha iyi performansla sonuçlanma eğiliminde olacaktır. Ancak algoritma, 100 veya 500 veya 1000 öğeyi almak için kaç öğenin alınacağı arasındaki ticareti analiz etmek veya optimize etmek için daha yavaş olacaktır. Ek öğelerin ne kadar alınmasının daha alakalı önerilerle sonuçlandığını görmek için çevrimdışı deneyler yapmanızı tavsiye ederim. Ve özellikle, tahmin edilen olasılık YİJ ise. Sinir ağı modelinize göre bire eşittir. Veya modelinizin tahminine göre alınan öğelerin tahmini Y değeri yüksekse, sonuç çok daha yüksek olur. Yalnızca 100 öğe yerine 500 öğe alacak olsaydınız, bu belki daha fazla öğe almayı tartışırdı. Albümü biraz yavaşlatsa bile. Ancak ayrı alma adımı ve sıralama adımı ile bu, günümüzde önerilen birçok sistemin hem hızlı hem de doğru sonuçlar vermesini sağlıyor. Çünkü geri alma adımı, daha ayrıntılı etkiyi ve iç ürünü yapmaya değmeyen birçok öğeyi budamaya çalışır. Ve sonra sıralama adımı, kullanıcının gerçekten keyif alacağı öğelerin neler olduğuna dair daha dikkatli bir tahmin yapar, işte bu kadar. Önerilen sisteminizin çok büyük film veya ürün kataloglarında veya elinizde olanlarda bile verimli çalışmasını bu şekilde sağlarsınız. Şimdi, önerilen sistemlerimiz kadar ticari açıdan da önemli olduğu ortaya çıktı, bunlarla ilişkili bazı önemli etik sorunlar da var. Ve ne yazık ki zarar yaratan önerilen sistemler var. Bu nedenle, kendi önerilen sisteminizi oluştururken, umarım etik bir yaklaşım benimsersiniz ve bunu kullanıcılarınıza hizmet etmek için kullanırsınız. Ve toplum kadar büyük, kendin ve çalışabileceğin şirket kadar. Bir sonraki videoda önerilen sistemlerle ilgili etik konulara bir göz atalım

## TensorFlow implementation of content-based filtering
Uygulama laboratuvarında, içerik tabanlı filtrelemeyi TensorFlow'da nasıl uygulayacağınızı göreceksiniz. Bu videoda yapmak istediğim şey, sizin sayenizde oynayabileceğiniz koddaki birkaç temel kavramdır. Hadi bir bakalım. Kodumuzun bir kullanıcı ağı ve işe yarayan bir filmle başladığını hatırlayın. Bunu TensorFlow'da uygulama şekliniz, daha önce bir dizi yoğun katman içeren bir sinir ağını uygulamamıza çok benzer. Sıralı bir model kullanacağız. Daha sonra bu örnekte, burada belirtilen gizli birim sayısına sahip iki yoğun katmanımız var ve son katmanda 32 birim ve çıktının 32 sayısı var. Sonra film ağı için, ona öğe ağı diyeceğim, çünkü filmler buradaki öğeler, kod böyle görünüyor. Bir kez daha, yoğun gizli katmanları birleştirdik, ardından 32 sayı veren bu katmanı izledik. Gizli katmanlar için, relu aktivasyon fonksiyonu olan varsayılan aktivasyon fonksiyonu seçimimizi kullanacağız. Ardından, TensorFlow Keras'a kullanıcı özelliklerini veya öğe özelliklerini, yani film özelliklerini iki sinir ağına nasıl besleyeceğini söylememiz gerekiyor. Bunu yapmanın sözdizimi budur. Bu, kullanıcı için giriş özelliklerini çıkarır ve ardından onu kullanıcıya iletir ve burada kullanıcı için vektör olan vu'yu hesaplamak için tanımladığımız şeyi verir. Sonra, bu algoritmanın biraz daha iyi çalışmasını sağlayan ek bir adım, buradaki vektör vu'yu bir uzunluğa sahip olacak şekilde normalleştiren bu satırdadır. Bu, l2 normu olarak da adlandırılan uzunluğu normalleştirir, ancak temel olarak vu vektörünün uzunluğu bire eşit olur. Sonra aynı şeyi item network için, movie network için yapıyoruz. Bu, öğe özelliklerini çıkarır ve onu yukarıda tanımladığımız öğe sinir ağına besler. Bu, film vektörü vm'yi hesaplar. Son olarak, adım aynı zamanda bu vektörü bir uzunluğa sahip olacak şekilde normalleştirir. vu ve vm'yi hesapladıktan sonra, bu iki vektör arasındaki iç çarpımı almalıyız. Bunu yapmanın sözdizimi budur. Keras'ın özel bir katman türü vardır, burada yoğun keras katmanları olduğuna dikkat edin, burada tf keras katmanları nokta. Görünüşe göre özel bir Keras katmanı var, sadece iki sayı arasında bir iç çarpım alıyorlar. Bunu, vu ve vm vektörleri arasındaki iç çarpımı almak için kullanacağız. Bu, sinir ağının çıktısını verir. Bu son tahmini verir. Son olarak, keras'a modelin girdilerinin ve çıktılarının ne olduğunu söylemek için, bu satır ona genel modelin girdileri kullanıcı özellikleri ve film veya öğe özellikleri ve çıktı olan bir model olduğunu söyler, bu az önce tanımladığımız çıktıdır. yukarıda. Bu modeli eğitmek için kullanacağımız maliyet fonksiyonu, ortalama karesel hata maliyet fonksiyonu olacaktır. Bunlar, içerik tabanlı filtrelemeyi bir sinir ağı olarak uygulamak için anahtar kod parçacıklarıdır. Uygulama laboratuvarında kodun geri kalanını görüyorsunuz, ancak umarız bununla oynayabilir ve tüm bu kod parçacıklarının içerik tabanlı bir filtreleme algoritmasının çalışan TensorFlow uygulamasına nasıl uyduğunu görebilirsiniz. Görünüşe göre daha önce bahsetmediğim bir adım daha var ama bunu yaparsanız, ki bu da vektör vu'nun uzunluğunu normalleştirir, bu algoritmanın biraz daha iyi çalışmasını sağlar. TensorFlows, vektörü normalleştiren bu l2 normalleştirilmiş harekete sahiptir, buna vektörün l2 normunu normalleştirme de denir, dolayısıyla fonksiyonun adıdır. Bu kadar. Tavsiye sistemleriyle ilgili tüm bu materyal boyunca bana bağlı kaldığınız için teşekkürler, bu heyecan verici bir teknoloji. Umarım bu haftaki uygulama laboratuvarlarında bu fikirler ve kodlarla oynamaktan keyif alırsınız. Bu da bizi tavsiye sistemlerindeki bu videoların çoğuna ve bu uzmanlık için önümüzdeki haftadan son haftaya kadar götürüyor. Ben de haftaya seni görmeyi dört gözle bekliyorum. Takviyeli öğrenmenin heyecan verici teknolojisi hakkında konuşacağız. Kısa sınavlarda ve uygulama laboratuvarlarında eğlenmenizi umuyorum ve gelecek hafta sizi görmeyi dört gözle bekliyorum.


